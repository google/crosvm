#![allow(unaligned_references, deref_nullptr)]
/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const WHV_PROCESSOR_FEATURES_BANKS_COUNT: u32 = 2;
pub const WHV_HYPERCALL_CONTEXT_MAX_XMM_REGISTERS: u32 = 6;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type PUINT = *mut ::std::os::raw::c_uint;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeHypervisorPresent: WHV_CAPABILITY_CODE = 0;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeFeatures: WHV_CAPABILITY_CODE = 1;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExtendedVmExits: WHV_CAPABILITY_CODE = 2;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExceptionExitBitmap: WHV_CAPABILITY_CODE = 3;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeX64MsrExitBitmap: WHV_CAPABILITY_CODE = 4;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorVendor: WHV_CAPABILITY_CODE = 4096;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorFeatures: WHV_CAPABILITY_CODE = 4097;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorClFlushSize: WHV_CAPABILITY_CODE = 4098;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorXsaveFeatures: WHV_CAPABILITY_CODE = 4099;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorClockFrequency: WHV_CAPABILITY_CODE = 4100;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeInterruptClockFrequency: WHV_CAPABILITY_CODE = 4101;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorFeaturesBanks: WHV_CAPABILITY_CODE = 4102;
pub type WHV_CAPABILITY_CODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY_FEATURES {
    pub __bindgen_anon_1: WHV_CAPABILITY_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn PartialUnmap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PartialUnmap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LocalApicEmulation(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocalApicEmulation(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xsave(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xsave(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPageTracking(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DirtyPageTracking(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculationControl(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SpeculationControl(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApicRemoteRead(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ApicRemoteRead(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleSuspend(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IdleSuspend(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 57u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 57u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PartialUnmap: UINT64,
        LocalApicEmulation: UINT64,
        Xsave: UINT64,
        DirtyPageTracking: UINT64,
        SpeculationControl: UINT64,
        ApicRemoteRead: UINT64,
        IdleSuspend: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PartialUnmap: u64 = unsafe { ::std::mem::transmute(PartialUnmap) };
            PartialUnmap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LocalApicEmulation: u64 = unsafe { ::std::mem::transmute(LocalApicEmulation) };
            LocalApicEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Xsave: u64 = unsafe { ::std::mem::transmute(Xsave) };
            Xsave as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DirtyPageTracking: u64 = unsafe { ::std::mem::transmute(DirtyPageTracking) };
            DirtyPageTracking as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SpeculationControl: u64 = unsafe { ::std::mem::transmute(SpeculationControl) };
            SpeculationControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ApicRemoteRead: u64 = unsafe { ::std::mem::transmute(ApicRemoteRead) };
            ApicRemoteRead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let IdleSuspend: u64 = unsafe { ::std::mem::transmute(IdleSuspend) };
            IdleSuspend as u64
        });
        __bindgen_bitfield_unit.set(7usize, 57u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_CAPABILITY_FEATURES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __C_ASSERT__ = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_EXTENDED_VM_EXITS {
    pub __bindgen_anon_1: WHV_EXTENDED_VM_EXITS__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1)
        )
    );
}
impl WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    #[inline]
    pub fn X64CpuidExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64CpuidExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64MsrExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64MsrExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExceptionExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64RdtscExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64RdtscExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64ApicSmiExitTrap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64ApicSmiExitTrap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HypercallExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HypercallExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64ApicInitSipiExitTrap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64ApicInitSipiExitTrap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64ApicWriteLint0ExitTrap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64ApicWriteLint0ExitTrap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64ApicWriteLint1ExitTrap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64ApicWriteLint1ExitTrap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64ApicWriteSvrExitTrap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64ApicWriteSvrExitTrap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 54u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 54u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        X64CpuidExit: UINT64,
        X64MsrExit: UINT64,
        ExceptionExit: UINT64,
        X64RdtscExit: UINT64,
        X64ApicSmiExitTrap: UINT64,
        HypercallExit: UINT64,
        X64ApicInitSipiExitTrap: UINT64,
        X64ApicWriteLint0ExitTrap: UINT64,
        X64ApicWriteLint1ExitTrap: UINT64,
        X64ApicWriteSvrExitTrap: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let X64CpuidExit: u64 = unsafe { ::std::mem::transmute(X64CpuidExit) };
            X64CpuidExit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let X64MsrExit: u64 = unsafe { ::std::mem::transmute(X64MsrExit) };
            X64MsrExit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExceptionExit: u64 = unsafe { ::std::mem::transmute(ExceptionExit) };
            ExceptionExit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let X64RdtscExit: u64 = unsafe { ::std::mem::transmute(X64RdtscExit) };
            X64RdtscExit as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let X64ApicSmiExitTrap: u64 = unsafe { ::std::mem::transmute(X64ApicSmiExitTrap) };
            X64ApicSmiExitTrap as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HypercallExit: u64 = unsafe { ::std::mem::transmute(HypercallExit) };
            HypercallExit as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let X64ApicInitSipiExitTrap: u64 =
                unsafe { ::std::mem::transmute(X64ApicInitSipiExitTrap) };
            X64ApicInitSipiExitTrap as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let X64ApicWriteLint0ExitTrap: u64 =
                unsafe { ::std::mem::transmute(X64ApicWriteLint0ExitTrap) };
            X64ApicWriteLint0ExitTrap as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let X64ApicWriteLint1ExitTrap: u64 =
                unsafe { ::std::mem::transmute(X64ApicWriteLint1ExitTrap) };
            X64ApicWriteLint1ExitTrap as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let X64ApicWriteSvrExitTrap: u64 =
                unsafe { ::std::mem::transmute(X64ApicWriteSvrExitTrap) };
            X64ApicWriteSvrExitTrap as u64
        });
        __bindgen_bitfield_unit.set(10usize, 54u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EXTENDED_VM_EXITS>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EXTENDED_VM_EXITS),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_EXTENDED_VM_EXITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorAmd: WHV_PROCESSOR_VENDOR = 0;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorIntel: WHV_PROCESSOR_VENDOR = 1;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorHygon: WHV_PROCESSOR_VENDOR = 2;
pub type WHV_PROCESSOR_VENDOR = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PROCESSOR_FEATURES {
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn Sse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LahfSahfSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LahfSahfSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ssse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Ssse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4aSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4aSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XopSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XopSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PopCntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PopCntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cmpxchg16bSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Cmpxchg16bSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Altmovcr8Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Altmovcr8Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LzcntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LzcntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MisAlignSseSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MisAlignSseSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MmxExtSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MmxExtSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Amd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Amd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAmd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedAmd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Page1GbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Page1GbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Fma4Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Fma4Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn F16CSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_F16CSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdRandSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdRandSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdWrFsGsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdWrFsGsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmepSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmepSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnhancedFastStringSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnhancedFastStringSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MovbeSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MovbeSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Npiep1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Npiep1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DepX87FPUSaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DepX87FPUSaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdSeedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdSeedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AdxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IntelPrefetchSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IntelPrefetchSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmapSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmapSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HleSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HleSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtmSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RtmSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdtscpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdtscpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClflushoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClflushoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClwbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClwbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ShaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X87PointersSavedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X87PointersSavedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InvpcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InvpcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StibpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StibpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbpbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbpbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbdSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbdSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FastShortRepMovSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FastShortRepMovSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdclNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdclNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsAllSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsAllSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RsbANo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RsbANo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdPidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdPidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmipSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UmipSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MdsNoSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MdsNoSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MdClearSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MdClearSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved6(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved6(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Sse3Support: UINT64,
        LahfSahfSupport: UINT64,
        Ssse3Support: UINT64,
        Sse4_1Support: UINT64,
        Sse4_2Support: UINT64,
        Sse4aSupport: UINT64,
        XopSupport: UINT64,
        PopCntSupport: UINT64,
        Cmpxchg16bSupport: UINT64,
        Altmovcr8Support: UINT64,
        LzcntSupport: UINT64,
        MisAlignSseSupport: UINT64,
        MmxExtSupport: UINT64,
        Amd3DNowSupport: UINT64,
        ExtendedAmd3DNowSupport: UINT64,
        Page1GbSupport: UINT64,
        AesSupport: UINT64,
        PclmulqdqSupport: UINT64,
        PcidSupport: UINT64,
        Fma4Support: UINT64,
        F16CSupport: UINT64,
        RdRandSupport: UINT64,
        RdWrFsGsSupport: UINT64,
        SmepSupport: UINT64,
        EnhancedFastStringSupport: UINT64,
        Bmi1Support: UINT64,
        Bmi2Support: UINT64,
        Reserved1: UINT64,
        MovbeSupport: UINT64,
        Npiep1Support: UINT64,
        DepX87FPUSaveSupport: UINT64,
        RdSeedSupport: UINT64,
        AdxSupport: UINT64,
        IntelPrefetchSupport: UINT64,
        SmapSupport: UINT64,
        HleSupport: UINT64,
        RtmSupport: UINT64,
        RdtscpSupport: UINT64,
        ClflushoptSupport: UINT64,
        ClwbSupport: UINT64,
        ShaSupport: UINT64,
        X87PointersSavedSupport: UINT64,
        InvpcidSupport: UINT64,
        IbrsSupport: UINT64,
        StibpSupport: UINT64,
        IbpbSupport: UINT64,
        Reserved2: UINT64,
        SsbdSupport: UINT64,
        FastShortRepMovSupport: UINT64,
        Reserved3: UINT64,
        RdclNo: UINT64,
        IbrsAllSupport: UINT64,
        Reserved4: UINT64,
        SsbNo: UINT64,
        RsbANo: UINT64,
        Reserved5: UINT64,
        RdPidSupport: UINT64,
        UmipSupport: UINT64,
        MdsNoSupport: UINT64,
        MdClearSupport: UINT64,
        Reserved6: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Sse3Support: u64 = unsafe { ::std::mem::transmute(Sse3Support) };
            Sse3Support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LahfSahfSupport: u64 = unsafe { ::std::mem::transmute(LahfSahfSupport) };
            LahfSahfSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Ssse3Support: u64 = unsafe { ::std::mem::transmute(Ssse3Support) };
            Ssse3Support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Sse4_1Support: u64 = unsafe { ::std::mem::transmute(Sse4_1Support) };
            Sse4_1Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Sse4_2Support: u64 = unsafe { ::std::mem::transmute(Sse4_2Support) };
            Sse4_2Support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Sse4aSupport: u64 = unsafe { ::std::mem::transmute(Sse4aSupport) };
            Sse4aSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let XopSupport: u64 = unsafe { ::std::mem::transmute(XopSupport) };
            XopSupport as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PopCntSupport: u64 = unsafe { ::std::mem::transmute(PopCntSupport) };
            PopCntSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Cmpxchg16bSupport: u64 = unsafe { ::std::mem::transmute(Cmpxchg16bSupport) };
            Cmpxchg16bSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Altmovcr8Support: u64 = unsafe { ::std::mem::transmute(Altmovcr8Support) };
            Altmovcr8Support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LzcntSupport: u64 = unsafe { ::std::mem::transmute(LzcntSupport) };
            LzcntSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MisAlignSseSupport: u64 = unsafe { ::std::mem::transmute(MisAlignSseSupport) };
            MisAlignSseSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let MmxExtSupport: u64 = unsafe { ::std::mem::transmute(MmxExtSupport) };
            MmxExtSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Amd3DNowSupport: u64 = unsafe { ::std::mem::transmute(Amd3DNowSupport) };
            Amd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ExtendedAmd3DNowSupport: u64 =
                unsafe { ::std::mem::transmute(ExtendedAmd3DNowSupport) };
            ExtendedAmd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Page1GbSupport: u64 = unsafe { ::std::mem::transmute(Page1GbSupport) };
            Page1GbSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AesSupport: u64 = unsafe { ::std::mem::transmute(AesSupport) };
            AesSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let PclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(PclmulqdqSupport) };
            PclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PcidSupport: u64 = unsafe { ::std::mem::transmute(PcidSupport) };
            PcidSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Fma4Support: u64 = unsafe { ::std::mem::transmute(Fma4Support) };
            Fma4Support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let F16CSupport: u64 = unsafe { ::std::mem::transmute(F16CSupport) };
            F16CSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RdRandSupport: u64 = unsafe { ::std::mem::transmute(RdRandSupport) };
            RdRandSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let RdWrFsGsSupport: u64 = unsafe { ::std::mem::transmute(RdWrFsGsSupport) };
            RdWrFsGsSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SmepSupport: u64 = unsafe { ::std::mem::transmute(SmepSupport) };
            SmepSupport as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EnhancedFastStringSupport: u64 =
                unsafe { ::std::mem::transmute(EnhancedFastStringSupport) };
            EnhancedFastStringSupport as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let Bmi1Support: u64 = unsafe { ::std::mem::transmute(Bmi1Support) };
            Bmi1Support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Bmi2Support: u64 = unsafe { ::std::mem::transmute(Bmi2Support) };
            Bmi2Support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let MovbeSupport: u64 = unsafe { ::std::mem::transmute(MovbeSupport) };
            MovbeSupport as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Npiep1Support: u64 = unsafe { ::std::mem::transmute(Npiep1Support) };
            Npiep1Support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DepX87FPUSaveSupport: u64 = unsafe { ::std::mem::transmute(DepX87FPUSaveSupport) };
            DepX87FPUSaveSupport as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let RdSeedSupport: u64 = unsafe { ::std::mem::transmute(RdSeedSupport) };
            RdSeedSupport as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let AdxSupport: u64 = unsafe { ::std::mem::transmute(AdxSupport) };
            AdxSupport as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let IntelPrefetchSupport: u64 = unsafe { ::std::mem::transmute(IntelPrefetchSupport) };
            IntelPrefetchSupport as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let SmapSupport: u64 = unsafe { ::std::mem::transmute(SmapSupport) };
            SmapSupport as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let HleSupport: u64 = unsafe { ::std::mem::transmute(HleSupport) };
            HleSupport as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let RtmSupport: u64 = unsafe { ::std::mem::transmute(RtmSupport) };
            RtmSupport as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let RdtscpSupport: u64 = unsafe { ::std::mem::transmute(RdtscpSupport) };
            RdtscpSupport as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let ClflushoptSupport: u64 = unsafe { ::std::mem::transmute(ClflushoptSupport) };
            ClflushoptSupport as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let ClwbSupport: u64 = unsafe { ::std::mem::transmute(ClwbSupport) };
            ClwbSupport as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let ShaSupport: u64 = unsafe { ::std::mem::transmute(ShaSupport) };
            ShaSupport as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let X87PointersSavedSupport: u64 =
                unsafe { ::std::mem::transmute(X87PointersSavedSupport) };
            X87PointersSavedSupport as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let InvpcidSupport: u64 = unsafe { ::std::mem::transmute(InvpcidSupport) };
            InvpcidSupport as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let IbrsSupport: u64 = unsafe { ::std::mem::transmute(IbrsSupport) };
            IbrsSupport as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let StibpSupport: u64 = unsafe { ::std::mem::transmute(StibpSupport) };
            StibpSupport as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let IbpbSupport: u64 = unsafe { ::std::mem::transmute(IbpbSupport) };
            IbpbSupport as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let SsbdSupport: u64 = unsafe { ::std::mem::transmute(SsbdSupport) };
            SsbdSupport as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let FastShortRepMovSupport: u64 =
                unsafe { ::std::mem::transmute(FastShortRepMovSupport) };
            FastShortRepMovSupport as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let Reserved3: u64 = unsafe { ::std::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let RdclNo: u64 = unsafe { ::std::mem::transmute(RdclNo) };
            RdclNo as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let IbrsAllSupport: u64 = unsafe { ::std::mem::transmute(IbrsAllSupport) };
            IbrsAllSupport as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let Reserved4: u64 = unsafe { ::std::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let SsbNo: u64 = unsafe { ::std::mem::transmute(SsbNo) };
            SsbNo as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let RsbANo: u64 = unsafe { ::std::mem::transmute(RsbANo) };
            RsbANo as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let Reserved5: u64 = unsafe { ::std::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let RdPidSupport: u64 = unsafe { ::std::mem::transmute(RdPidSupport) };
            RdPidSupport as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let UmipSupport: u64 = unsafe { ::std::mem::transmute(UmipSupport) };
            UmipSupport as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let MdsNoSupport: u64 = unsafe { ::std::mem::transmute(MdsNoSupport) };
            MdsNoSupport as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let MdClearSupport: u64 = unsafe { ::std::mem::transmute(MdClearSupport) };
            MdClearSupport as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let Reserved6: u64 = unsafe { ::std::mem::transmute(Reserved6) };
            Reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_PROCESSOR_FEATURES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PROCESSOR_FEATURES1 {
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES1__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES1__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES1__bindgen_ty_1)
        )
    );
}
impl WHV_PROCESSOR_FEATURES1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ClZeroSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClZeroSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved1: UINT64,
        ClZeroSupport: UINT64,
        Reserved2: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ClZeroSupport: u64 = unsafe { ::std::mem::transmute(ClZeroSupport) };
            ClZeroSupport as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES1>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_FEATURES1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES1>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_FEATURES1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES1>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES1),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_PROCESSOR_FEATURES1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES_BANKS {
    pub BanksCount: UINT32,
    pub Reserved0: UINT32,
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1,
    pub AsUINT64: [UINT64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1 {
    pub Bank0: WHV_PROCESSOR_FEATURES,
    pub Bank1: WHV_PROCESSOR_FEATURES1,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1>()))
                .Bank0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Bank0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1>()))
                .Bank1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Bank1)
        )
    );
}
impl Default for WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1>())).AsUINT64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_PROCESSOR_FEATURES_BANKS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES_BANKS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES_BANKS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_FEATURES_BANKS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES_BANKS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_FEATURES_BANKS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES_BANKS>())).BanksCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS),
            "::",
            stringify!(BanksCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES_BANKS>())).Reserved0 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES_BANKS),
            "::",
            stringify!(Reserved0)
        )
    );
}
impl Default for WHV_PROCESSOR_FEATURES_BANKS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHV_PROCESSOR_XSAVE_FEATURES {
    pub __bindgen_anon_1: _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
}
impl _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn XsaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AvxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AvxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MpxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MpxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512DQSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512DQSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512CDSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512CDSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BWSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BWSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VLSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VLSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveCompSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveCompSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveSupervisorSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupervisorSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xcr1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xcr1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BitalgSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BitalgSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512IfmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512IfmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmiSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmiSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VnniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VnniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GfniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_GfniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VaesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VaesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VPopcntdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VPopcntdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VpclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VpclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512Bf16Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512Bf16Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512Vp2IntersectSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512Vp2IntersectSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 39u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 39u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XsaveSupport: UINT64,
        XsaveoptSupport: UINT64,
        AvxSupport: UINT64,
        Avx2Support: UINT64,
        FmaSupport: UINT64,
        MpxSupport: UINT64,
        Avx512Support: UINT64,
        Avx512DQSupport: UINT64,
        Avx512CDSupport: UINT64,
        Avx512BWSupport: UINT64,
        Avx512VLSupport: UINT64,
        XsaveCompSupport: UINT64,
        XsaveSupervisorSupport: UINT64,
        Xcr1Support: UINT64,
        Avx512BitalgSupport: UINT64,
        Avx512IfmaSupport: UINT64,
        Avx512VBmiSupport: UINT64,
        Avx512VBmi2Support: UINT64,
        Avx512VnniSupport: UINT64,
        GfniSupport: UINT64,
        VaesSupport: UINT64,
        Avx512VPopcntdqSupport: UINT64,
        VpclmulqdqSupport: UINT64,
        Avx512Bf16Support: UINT64,
        Avx512Vp2IntersectSupport: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XsaveSupport: u64 = unsafe { ::std::mem::transmute(XsaveSupport) };
            XsaveSupport as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XsaveoptSupport: u64 = unsafe { ::std::mem::transmute(XsaveoptSupport) };
            XsaveoptSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AvxSupport: u64 = unsafe { ::std::mem::transmute(AvxSupport) };
            AvxSupport as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Avx2Support: u64 = unsafe { ::std::mem::transmute(Avx2Support) };
            Avx2Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FmaSupport: u64 = unsafe { ::std::mem::transmute(FmaSupport) };
            FmaSupport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MpxSupport: u64 = unsafe { ::std::mem::transmute(MpxSupport) };
            MpxSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Avx512Support: u64 = unsafe { ::std::mem::transmute(Avx512Support) };
            Avx512Support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Avx512DQSupport: u64 = unsafe { ::std::mem::transmute(Avx512DQSupport) };
            Avx512DQSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Avx512CDSupport: u64 = unsafe { ::std::mem::transmute(Avx512CDSupport) };
            Avx512CDSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Avx512BWSupport: u64 = unsafe { ::std::mem::transmute(Avx512BWSupport) };
            Avx512BWSupport as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Avx512VLSupport: u64 = unsafe { ::std::mem::transmute(Avx512VLSupport) };
            Avx512VLSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let XsaveCompSupport: u64 = unsafe { ::std::mem::transmute(XsaveCompSupport) };
            XsaveCompSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let XsaveSupervisorSupport: u64 =
                unsafe { ::std::mem::transmute(XsaveSupervisorSupport) };
            XsaveSupervisorSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Xcr1Support: u64 = unsafe { ::std::mem::transmute(Xcr1Support) };
            Xcr1Support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Avx512BitalgSupport: u64 = unsafe { ::std::mem::transmute(Avx512BitalgSupport) };
            Avx512BitalgSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Avx512IfmaSupport: u64 = unsafe { ::std::mem::transmute(Avx512IfmaSupport) };
            Avx512IfmaSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Avx512VBmiSupport: u64 = unsafe { ::std::mem::transmute(Avx512VBmiSupport) };
            Avx512VBmiSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Avx512VBmi2Support: u64 = unsafe { ::std::mem::transmute(Avx512VBmi2Support) };
            Avx512VBmi2Support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Avx512VnniSupport: u64 = unsafe { ::std::mem::transmute(Avx512VnniSupport) };
            Avx512VnniSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let GfniSupport: u64 = unsafe { ::std::mem::transmute(GfniSupport) };
            GfniSupport as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let VaesSupport: u64 = unsafe { ::std::mem::transmute(VaesSupport) };
            VaesSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Avx512VPopcntdqSupport: u64 =
                unsafe { ::std::mem::transmute(Avx512VPopcntdqSupport) };
            Avx512VPopcntdqSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let VpclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(VpclmulqdqSupport) };
            VpclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Avx512Bf16Support: u64 = unsafe { ::std::mem::transmute(Avx512Bf16Support) };
            Avx512Bf16Support as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Avx512Vp2IntersectSupport: u64 =
                unsafe { ::std::mem::transmute(Avx512Vp2IntersectSupport) };
            Avx512Vp2IntersectSupport as u64
        });
        __bindgen_bitfield_unit.set(25usize, 39u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_PROCESSOR_XSAVE_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for _WHV_PROCESSOR_XSAVE_FEATURES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WHV_PROCESSOR_XSAVE_FEATURES = _WHV_PROCESSOR_XSAVE_FEATURES;
pub type PWHV_PROCESSOR_XSAVE_FEATURES = *mut _WHV_PROCESSOR_XSAVE_FEATURES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_MSR_EXIT_BITMAP {
    pub AsUINT64: UINT64,
    pub __bindgen_anon_1: WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1)
        )
    );
}
impl WHV_X64_MSR_EXIT_BITMAP__bindgen_ty_1 {
    #[inline]
    pub fn UnhandledMsrs(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_UnhandledMsrs(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TscMsrWrite(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TscMsrWrite(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TscMsrRead(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_TscMsrRead(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ApicBaseMsrWrite(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ApicBaseMsrWrite(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MiscEnableMsrRead(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MiscEnableMsrRead(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn McUpdatePatchLevelMsrRead(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_McUpdatePatchLevelMsrRead(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UnhandledMsrs: UINT64,
        TscMsrWrite: UINT64,
        TscMsrRead: UINT64,
        ApicBaseMsrWrite: UINT64,
        MiscEnableMsrRead: UINT64,
        McUpdatePatchLevelMsrRead: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UnhandledMsrs: u64 = unsafe { ::std::mem::transmute(UnhandledMsrs) };
            UnhandledMsrs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TscMsrWrite: u64 = unsafe { ::std::mem::transmute(TscMsrWrite) };
            TscMsrWrite as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TscMsrRead: u64 = unsafe { ::std::mem::transmute(TscMsrRead) };
            TscMsrRead as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ApicBaseMsrWrite: u64 = unsafe { ::std::mem::transmute(ApicBaseMsrWrite) };
            ApicBaseMsrWrite as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MiscEnableMsrRead: u64 = unsafe { ::std::mem::transmute(MiscEnableMsrRead) };
            MiscEnableMsrRead as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let McUpdatePatchLevelMsrRead: u64 =
                unsafe { ::std::mem::transmute(McUpdatePatchLevelMsrRead) };
            McUpdatePatchLevelMsrRead as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_EXIT_BITMAP() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_EXIT_BITMAP>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_EXIT_BITMAP))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_EXIT_BITMAP>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_EXIT_BITMAP))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_EXIT_BITMAP>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_EXIT_BITMAP),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_MSR_EXIT_BITMAP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY {
    pub HypervisorPresent: BOOL,
    pub Features: WHV_CAPABILITY_FEATURES,
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorVendor: WHV_PROCESSOR_VENDOR,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ExceptionExitBitmap: UINT64,
    pub X64MsrExitBitmap: WHV_X64_MSR_EXIT_BITMAP,
    pub ProcessorClockFrequency: UINT64,
    pub InterruptClockFrequency: UINT64,
    pub ProcessorFeaturesBanks: WHV_PROCESSOR_FEATURES_BANKS,
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).HypervisorPresent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(HypervisorPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).Features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(Features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExtendedVmExits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorVendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorXsaveFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorClFlushSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExceptionExitBitmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).X64MsrExitBitmap as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(X64MsrExitBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorClockFrequency as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorClockFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).InterruptClockFrequency as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(InterruptClockFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorFeaturesBanks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorFeaturesBanks)
        )
    );
}
impl Default for WHV_CAPABILITY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WHV_PARTITION_HANDLE = *mut ::std::os::raw::c_void;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExtendedVmExits:
    WHV_PARTITION_PROPERTY_CODE = 1;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExceptionExitBitmap:
    WHV_PARTITION_PROPERTY_CODE = 2;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeSeparateSecurityDomain:
    WHV_PARTITION_PROPERTY_CODE = 3;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeNestedVirtualization:
    WHV_PARTITION_PROPERTY_CODE = 4;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeX64MsrExitBitmap:
    WHV_PARTITION_PROPERTY_CODE = 5;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4097;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorClFlushSize:
    WHV_PARTITION_PROPERTY_CODE = 4098;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidExitList:
    WHV_PARTITION_PROPERTY_CODE = 4099;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidResultList:
    WHV_PARTITION_PROPERTY_CODE = 4100;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeLocalApicEmulationMode:
    WHV_PARTITION_PROPERTY_CODE = 4101;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorXsaveFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4102;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorClockFrequency:
    WHV_PARTITION_PROPERTY_CODE = 4103;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeInterruptClockFrequency:
    WHV_PARTITION_PROPERTY_CODE = 4104;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeApicRemoteReadSupport:
    WHV_PARTITION_PROPERTY_CODE = 4105;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorFeaturesBanks:
    WHV_PARTITION_PROPERTY_CODE = 4106;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeReferenceTime:
    WHV_PARTITION_PROPERTY_CODE = 4107;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorCount:
    WHV_PARTITION_PROPERTY_CODE = 8191;
pub type WHV_PARTITION_PROPERTY_CODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_CPUID_RESULT {
    pub Function: UINT32,
    pub Reserved: [UINT32; 3usize],
    pub Eax: UINT32,
    pub Ebx: UINT32,
    pub Ecx: UINT32,
    pub Edx: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_RESULT>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Eax as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ebx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ecx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Edx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Edx)
        )
    );
}
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDivideErrorFault: WHV_EXCEPTION_TYPE = 0;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDebugTrapOrFault: WHV_EXCEPTION_TYPE = 1;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBreakpointTrap: WHV_EXCEPTION_TYPE = 3;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeOverflowTrap: WHV_EXCEPTION_TYPE = 4;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBoundRangeFault: WHV_EXCEPTION_TYPE = 5;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidOpcodeFault: WHV_EXCEPTION_TYPE = 6;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDeviceNotAvailableFault: WHV_EXCEPTION_TYPE = 7;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDoubleFaultAbort: WHV_EXCEPTION_TYPE = 8;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidTaskStateSegmentFault: WHV_EXCEPTION_TYPE =
    10;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSegmentNotPresentFault: WHV_EXCEPTION_TYPE = 11;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeStackFault: WHV_EXCEPTION_TYPE = 12;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeGeneralProtectionFault: WHV_EXCEPTION_TYPE = 13;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypePageFault: WHV_EXCEPTION_TYPE = 14;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeFloatingPointErrorFault: WHV_EXCEPTION_TYPE = 16;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeAlignmentCheckFault: WHV_EXCEPTION_TYPE = 17;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeMachineCheckAbort: WHV_EXCEPTION_TYPE = 18;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSimdFloatingPointFault: WHV_EXCEPTION_TYPE = 19;
pub type WHV_EXCEPTION_TYPE = ::std::os::raw::c_int;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeNone:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 0;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeXApic:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 1;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeX2Apic:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 2;
pub type WHV_X64_LOCAL_APIC_EMULATION_MODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PARTITION_PROPERTY {
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ProcessorCount: UINT32,
    pub CpuidExitList: [UINT32; 1usize],
    pub CpuidResultList: [WHV_X64_CPUID_RESULT; 1usize],
    pub ExceptionExitBitmap: UINT64,
    pub LocalApicEmulationMode: WHV_X64_LOCAL_APIC_EMULATION_MODE,
    pub SeparateSecurityDomain: BOOL,
    pub NestedVirtualization: BOOL,
    pub X64MsrExitBitmap: WHV_X64_MSR_EXIT_BITMAP,
    pub ProcessorClockFrequency: UINT64,
    pub InterruptClockFrequency: UINT64,
    pub ApicRemoteRead: BOOL,
    pub ProcessorFeaturesBanks: WHV_PROCESSOR_FEATURES_BANKS,
    pub ReferenceTime: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_PROPERTY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_PROPERTY>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_PROPERTY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExtendedVmExits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorXsaveFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorClFlushSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidExitList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidExitList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidResultList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidResultList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExceptionExitBitmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).LocalApicEmulationMode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(LocalApicEmulationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).SeparateSecurityDomain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(SeparateSecurityDomain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).NestedVirtualization as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(NestedVirtualization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).X64MsrExitBitmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(X64MsrExitBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorClockFrequency as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorClockFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).InterruptClockFrequency as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(InterruptClockFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ApicRemoteRead as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ApicRemoteRead)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorFeaturesBanks as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorFeaturesBanks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ReferenceTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ReferenceTime)
        )
    );
}
impl Default for WHV_PARTITION_PROPERTY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WHV_GUEST_PHYSICAL_ADDRESS = UINT64;
pub type WHV_GUEST_VIRTUAL_ADDRESS = UINT64;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagNone: WHV_MAP_GPA_RANGE_FLAGS = 0;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagRead: WHV_MAP_GPA_RANGE_FLAGS = 1;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagWrite: WHV_MAP_GPA_RANGE_FLAGS = 2;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagExecute: WHV_MAP_GPA_RANGE_FLAGS = 4;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagTrackDirtyPages: WHV_MAP_GPA_RANGE_FLAGS = 8;
pub type WHV_MAP_GPA_RANGE_FLAGS = ::std::os::raw::c_int;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagNone: WHV_TRANSLATE_GVA_FLAGS = 0;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateRead: WHV_TRANSLATE_GVA_FLAGS = 1;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateWrite: WHV_TRANSLATE_GVA_FLAGS = 2;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateExecute: WHV_TRANSLATE_GVA_FLAGS = 4;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagPrivilegeExempt: WHV_TRANSLATE_GVA_FLAGS = 8;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagSetPageTableBits: WHV_TRANSLATE_GVA_FLAGS = 16;
pub type WHV_TRANSLATE_GVA_FLAGS = ::std::os::raw::c_int;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultSuccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 0;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPageNotPresent:
    WHV_TRANSLATE_GVA_RESULT_CODE = 1;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPrivilegeViolation:
    WHV_TRANSLATE_GVA_RESULT_CODE = 2;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultInvalidPageTableFlags:
    WHV_TRANSLATE_GVA_RESULT_CODE = 3;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaUnmapped:
    WHV_TRANSLATE_GVA_RESULT_CODE = 4;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoReadAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 5;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoWriteAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 6;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaIllegalOverlayAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 7;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultIntercept:
    WHV_TRANSLATE_GVA_RESULT_CODE = 8;
pub type WHV_TRANSLATE_GVA_RESULT_CODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_TRANSLATE_GVA_RESULT {
    pub ResultCode: WHV_TRANSLATE_GVA_RESULT_CODE,
    pub Reserved: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_TRANSLATE_GVA_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_TRANSLATE_GVA_RESULT>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_TRANSLATE_GVA_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).ResultCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
}
impl Default for WHV_TRANSLATE_GVA_RESULT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_REGISTER_NAME_WHvX64RegisterRax: WHV_REGISTER_NAME = 0;
pub const WHV_REGISTER_NAME_WHvX64RegisterRcx: WHV_REGISTER_NAME = 1;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdx: WHV_REGISTER_NAME = 2;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbx: WHV_REGISTER_NAME = 3;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsp: WHV_REGISTER_NAME = 4;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbp: WHV_REGISTER_NAME = 5;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsi: WHV_REGISTER_NAME = 6;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdi: WHV_REGISTER_NAME = 7;
pub const WHV_REGISTER_NAME_WHvX64RegisterR8: WHV_REGISTER_NAME = 8;
pub const WHV_REGISTER_NAME_WHvX64RegisterR9: WHV_REGISTER_NAME = 9;
pub const WHV_REGISTER_NAME_WHvX64RegisterR10: WHV_REGISTER_NAME = 10;
pub const WHV_REGISTER_NAME_WHvX64RegisterR11: WHV_REGISTER_NAME = 11;
pub const WHV_REGISTER_NAME_WHvX64RegisterR12: WHV_REGISTER_NAME = 12;
pub const WHV_REGISTER_NAME_WHvX64RegisterR13: WHV_REGISTER_NAME = 13;
pub const WHV_REGISTER_NAME_WHvX64RegisterR14: WHV_REGISTER_NAME = 14;
pub const WHV_REGISTER_NAME_WHvX64RegisterR15: WHV_REGISTER_NAME = 15;
pub const WHV_REGISTER_NAME_WHvX64RegisterRip: WHV_REGISTER_NAME = 16;
pub const WHV_REGISTER_NAME_WHvX64RegisterRflags: WHV_REGISTER_NAME = 17;
pub const WHV_REGISTER_NAME_WHvX64RegisterEs: WHV_REGISTER_NAME = 18;
pub const WHV_REGISTER_NAME_WHvX64RegisterCs: WHV_REGISTER_NAME = 19;
pub const WHV_REGISTER_NAME_WHvX64RegisterSs: WHV_REGISTER_NAME = 20;
pub const WHV_REGISTER_NAME_WHvX64RegisterDs: WHV_REGISTER_NAME = 21;
pub const WHV_REGISTER_NAME_WHvX64RegisterFs: WHV_REGISTER_NAME = 22;
pub const WHV_REGISTER_NAME_WHvX64RegisterGs: WHV_REGISTER_NAME = 23;
pub const WHV_REGISTER_NAME_WHvX64RegisterLdtr: WHV_REGISTER_NAME = 24;
pub const WHV_REGISTER_NAME_WHvX64RegisterTr: WHV_REGISTER_NAME = 25;
pub const WHV_REGISTER_NAME_WHvX64RegisterIdtr: WHV_REGISTER_NAME = 26;
pub const WHV_REGISTER_NAME_WHvX64RegisterGdtr: WHV_REGISTER_NAME = 27;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr0: WHV_REGISTER_NAME = 28;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr2: WHV_REGISTER_NAME = 29;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr3: WHV_REGISTER_NAME = 30;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr4: WHV_REGISTER_NAME = 31;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr8: WHV_REGISTER_NAME = 32;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr0: WHV_REGISTER_NAME = 33;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr1: WHV_REGISTER_NAME = 34;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr2: WHV_REGISTER_NAME = 35;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr3: WHV_REGISTER_NAME = 36;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr6: WHV_REGISTER_NAME = 37;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr7: WHV_REGISTER_NAME = 38;
pub const WHV_REGISTER_NAME_WHvX64RegisterXCr0: WHV_REGISTER_NAME = 39;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm0: WHV_REGISTER_NAME = 4096;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm1: WHV_REGISTER_NAME = 4097;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm2: WHV_REGISTER_NAME = 4098;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm3: WHV_REGISTER_NAME = 4099;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm4: WHV_REGISTER_NAME = 4100;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm5: WHV_REGISTER_NAME = 4101;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm6: WHV_REGISTER_NAME = 4102;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm7: WHV_REGISTER_NAME = 4103;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm8: WHV_REGISTER_NAME = 4104;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm9: WHV_REGISTER_NAME = 4105;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm10: WHV_REGISTER_NAME = 4106;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm11: WHV_REGISTER_NAME = 4107;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm12: WHV_REGISTER_NAME = 4108;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm13: WHV_REGISTER_NAME = 4109;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm14: WHV_REGISTER_NAME = 4110;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm15: WHV_REGISTER_NAME = 4111;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx0: WHV_REGISTER_NAME = 4112;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx1: WHV_REGISTER_NAME = 4113;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx2: WHV_REGISTER_NAME = 4114;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx3: WHV_REGISTER_NAME = 4115;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx4: WHV_REGISTER_NAME = 4116;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx5: WHV_REGISTER_NAME = 4117;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx6: WHV_REGISTER_NAME = 4118;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx7: WHV_REGISTER_NAME = 4119;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpControlStatus: WHV_REGISTER_NAME = 4120;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmmControlStatus: WHV_REGISTER_NAME = 4121;
pub const WHV_REGISTER_NAME_WHvX64RegisterTsc: WHV_REGISTER_NAME = 8192;
pub const WHV_REGISTER_NAME_WHvX64RegisterEfer: WHV_REGISTER_NAME = 8193;
pub const WHV_REGISTER_NAME_WHvX64RegisterKernelGsBase: WHV_REGISTER_NAME = 8194;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicBase: WHV_REGISTER_NAME = 8195;
pub const WHV_REGISTER_NAME_WHvX64RegisterPat: WHV_REGISTER_NAME = 8196;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterCs: WHV_REGISTER_NAME = 8197;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEip: WHV_REGISTER_NAME = 8198;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEsp: WHV_REGISTER_NAME = 8199;
pub const WHV_REGISTER_NAME_WHvX64RegisterStar: WHV_REGISTER_NAME = 8200;
pub const WHV_REGISTER_NAME_WHvX64RegisterLstar: WHV_REGISTER_NAME = 8201;
pub const WHV_REGISTER_NAME_WHvX64RegisterCstar: WHV_REGISTER_NAME = 8202;
pub const WHV_REGISTER_NAME_WHvX64RegisterSfmask: WHV_REGISTER_NAME = 8203;
pub const WHV_REGISTER_NAME_WHvX64RegisterInitialApicId: WHV_REGISTER_NAME = 8204;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrCap: WHV_REGISTER_NAME = 8205;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrDefType: WHV_REGISTER_NAME = 8206;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase0: WHV_REGISTER_NAME = 8208;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase1: WHV_REGISTER_NAME = 8209;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase2: WHV_REGISTER_NAME = 8210;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase3: WHV_REGISTER_NAME = 8211;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase4: WHV_REGISTER_NAME = 8212;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase5: WHV_REGISTER_NAME = 8213;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase6: WHV_REGISTER_NAME = 8214;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase7: WHV_REGISTER_NAME = 8215;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase8: WHV_REGISTER_NAME = 8216;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase9: WHV_REGISTER_NAME = 8217;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseA: WHV_REGISTER_NAME = 8218;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseB: WHV_REGISTER_NAME = 8219;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseC: WHV_REGISTER_NAME = 8220;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseD: WHV_REGISTER_NAME = 8221;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseE: WHV_REGISTER_NAME = 8222;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseF: WHV_REGISTER_NAME = 8223;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask0: WHV_REGISTER_NAME = 8256;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask1: WHV_REGISTER_NAME = 8257;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask2: WHV_REGISTER_NAME = 8258;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask3: WHV_REGISTER_NAME = 8259;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask4: WHV_REGISTER_NAME = 8260;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask5: WHV_REGISTER_NAME = 8261;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask6: WHV_REGISTER_NAME = 8262;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask7: WHV_REGISTER_NAME = 8263;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask8: WHV_REGISTER_NAME = 8264;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask9: WHV_REGISTER_NAME = 8265;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskA: WHV_REGISTER_NAME = 8266;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskB: WHV_REGISTER_NAME = 8267;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskC: WHV_REGISTER_NAME = 8268;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskD: WHV_REGISTER_NAME = 8269;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskE: WHV_REGISTER_NAME = 8270;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskF: WHV_REGISTER_NAME = 8271;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix64k00000: WHV_REGISTER_NAME = 8304;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16k80000: WHV_REGISTER_NAME = 8305;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16kA0000: WHV_REGISTER_NAME = 8306;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC0000: WHV_REGISTER_NAME = 8307;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC8000: WHV_REGISTER_NAME = 8308;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD0000: WHV_REGISTER_NAME = 8309;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD8000: WHV_REGISTER_NAME = 8310;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE0000: WHV_REGISTER_NAME = 8311;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE8000: WHV_REGISTER_NAME = 8312;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF0000: WHV_REGISTER_NAME = 8313;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF8000: WHV_REGISTER_NAME = 8314;
pub const WHV_REGISTER_NAME_WHvX64RegisterTscAux: WHV_REGISTER_NAME = 8315;
pub const WHV_REGISTER_NAME_WHvX64RegisterBndcfgs: WHV_REGISTER_NAME = 8316;
pub const WHV_REGISTER_NAME_WHvX64RegisterSpecCtrl: WHV_REGISTER_NAME = 8324;
pub const WHV_REGISTER_NAME_WHvX64RegisterPredCmd: WHV_REGISTER_NAME = 8325;
pub const WHV_REGISTER_NAME_WHvX64RegisterTscVirtualOffset: WHV_REGISTER_NAME = 8327;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicId: WHV_REGISTER_NAME = 12290;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicVersion: WHV_REGISTER_NAME = 12291;
pub const WHV_REGISTER_NAME_WHvRegisterPendingInterruption: WHV_REGISTER_NAME = -2147483648;
pub const WHV_REGISTER_NAME_WHvRegisterInterruptState: WHV_REGISTER_NAME = -2147483647;
pub const WHV_REGISTER_NAME_WHvRegisterPendingEvent: WHV_REGISTER_NAME = -2147483646;
pub const WHV_REGISTER_NAME_WHvX64RegisterDeliverabilityNotifications: WHV_REGISTER_NAME =
    -2147483644;
pub const WHV_REGISTER_NAME_WHvRegisterInternalActivityState: WHV_REGISTER_NAME = -2147483643;
pub const WHV_REGISTER_NAME_WHvX64RegisterPendingDebugException: WHV_REGISTER_NAME = -2147483642;
pub type WHV_REGISTER_NAME = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_UINT128 {
    pub __bindgen_anon_1: WHV_UINT128__bindgen_ty_1,
    pub Dword: [UINT32; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_UINT128__bindgen_ty_1 {
    pub Low64: UINT64,
    pub High64: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_UINT128__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_UINT128__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).Low64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(Low64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).High64 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(High64)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_UINT128() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_UINT128>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_UINT128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128>())).Dword as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128),
            "::",
            stringify!(Dword)
        )
    );
}
impl Default for WHV_UINT128 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_FP_REGISTER__bindgen_ty_1 {
    pub Mantissa: UINT64,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_REGISTER__bindgen_ty_1>())).Mantissa as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Mantissa)
        )
    );
}
impl WHV_X64_FP_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn BiasedExponent(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_BiasedExponent(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn Sign(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sign(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BiasedExponent: UINT64,
        Sign: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let BiasedExponent: u64 = unsafe { ::std::mem::transmute(BiasedExponent) };
            BiasedExponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Sign: u64 = unsafe { ::std::mem::transmute(Sign) };
            Sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_REGISTER>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_FP_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_FP_REGISTER>())).AsUINT128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
impl Default for WHV_X64_FP_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub FpControl: UINT16,
    pub FpStatus: UINT16,
    pub FpTag: UINT8,
    pub Reserved: UINT8,
    pub LastFpOp: UINT16,
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRip: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpEip: UINT32,
    pub LastFpCs: UINT16,
    pub Reserved2: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpEip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpEip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpCs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpCs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved2 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRip)
        )
    );
}
impl Default for WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpControl
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpTag
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).Reserved
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).LastFpOp
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(LastFpOp)
        )
    );
}
impl Default for WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
impl Default for WHV_X64_FP_CONTROL_STATUS_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub XmmStatusControl: UINT32,
    pub XmmStatusControlMask: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRdp: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpDp: UINT32,
    pub LastFpDs: UINT16,
    pub Reserved: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRdp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRdp)
        )
    );
}
impl Default for WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControlMask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControlMask)
        )
    );
}
impl Default for WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
impl Default for WHV_X64_XMM_CONTROL_STATUS_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER {
    pub Base: UINT64,
    pub Limit: UINT32,
    pub Selector: UINT16,
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_SEGMENT_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub Attributes: UINT16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SegmentType(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SegmentType(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NonSystemSegment(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonSystemSegment(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DescriptorPrivilegeLevel(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DescriptorPrivilegeLevel(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Present(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Long(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Long(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Default(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SegmentType: UINT16,
        NonSystemSegment: UINT16,
        DescriptorPrivilegeLevel: UINT16,
        Present: UINT16,
        Reserved: UINT16,
        Available: UINT16,
        Long: UINT16,
        Default: UINT16,
        Granularity: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SegmentType: u16 = unsafe { ::std::mem::transmute(SegmentType) };
            SegmentType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NonSystemSegment: u16 = unsafe { ::std::mem::transmute(NonSystemSegment) };
            NonSystemSegment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let DescriptorPrivilegeLevel: u16 =
                unsafe { ::std::mem::transmute(DescriptorPrivilegeLevel) };
            DescriptorPrivilegeLevel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Present: u16 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Available: u16 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Long: u16 = unsafe { ::std::mem::transmute(Long) };
            Long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Default: u16 = unsafe { ::std::mem::transmute(Default) };
            Default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Granularity: u16 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>())).Attributes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Attributes)
        )
    );
}
impl Default for WHV_X64_SEGMENT_REGISTER__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Selector as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Selector)
        )
    );
}
impl Default for WHV_X64_SEGMENT_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_TABLE_REGISTER {
    pub Pad: [UINT16; 3usize],
    pub Limit: UINT16,
    pub Base: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_TABLE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_TABLE_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_TABLE_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Limit as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_INTERRUPT_STATE_REGISTER {
    pub __bindgen_anon_1: WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptShadow(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NmiMasked(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiMasked(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptShadow: UINT64,
        NmiMasked: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptShadow: u64 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NmiMasked: u64 = unsafe { ::std::mem::transmute(NmiMasked) };
            NmiMasked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_INTERRUPT_STATE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPT_STATE_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_INTERRUPT_STATE_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_INTERRUPTION_REGISTER {
    pub __bindgen_anon_1: WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ErrorCode: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>()))
                .ErrorCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptionPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionLength(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NestedEvent(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NestedEvent(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionVector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionVector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptionPending: UINT32,
        InterruptionType: UINT32,
        DeliverErrorCode: UINT32,
        InstructionLength: UINT32,
        NestedEvent: UINT32,
        Reserved: UINT32,
        InterruptionVector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptionPending: u32 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let InterruptionType: u32 = unsafe { ::std::mem::transmute(InterruptionType) };
            InterruptionType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let InstructionLength: u32 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let NestedEvent: u32 = unsafe { ::std::mem::transmute(NestedEvent) };
            NestedEvent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let InterruptionVector: u32 = unsafe { ::std::mem::transmute(InterruptionVector) };
            InterruptionVector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_PENDING_INTERRUPTION_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn NmiNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptPriority(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptPriority(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NmiNotification: UINT64,
        InterruptNotification: UINT64,
        InterruptPriority: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NmiNotification: u64 = unsafe { ::std::mem::transmute(NmiNotification) };
            NmiNotification as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InterruptNotification: u64 =
                unsafe { ::std::mem::transmute(InterruptNotification) };
            InterruptNotification as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let InterruptPriority: u64 = unsafe { ::std::mem::transmute(InterruptPriority) };
            InterruptPriority as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>())).AsUINT64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventException: WHV_X64_PENDING_EVENT_TYPE = 0;
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventExtInt: WHV_X64_PENDING_EVENT_TYPE = 5;
pub type WHV_X64_PENDING_EVENT_TYPE = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXCEPTION_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>())).ErrorCode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>()))
                .ExceptionParameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
impl WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT32,
        EventType: UINT32,
        Reserved0: UINT32,
        DeliverErrorCode: UINT32,
        Reserved1: UINT32,
        Vector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u32 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u32 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Vector: u32 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXCEPTION_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXCEPTION_EVENT>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_PENDING_EXCEPTION_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
impl Default for WHV_X64_PENDING_EXCEPTION_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXT_INT_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub Reserved2: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>())).Reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1),
            "::",
            stringify!(Reserved2)
        )
    );
}
impl WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT64,
        EventType: UINT64,
        Reserved0: UINT64,
        Vector: UINT64,
        Reserved1: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u64 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u64 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u64 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Vector: u64 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXT_INT_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXT_INT_EVENT>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_X64_PENDING_EXT_INT_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT>())).AsUINT128 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
impl Default for WHV_X64_PENDING_EXT_INT_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_INTERNAL_ACTIVITY_REGISTER {
    pub __bindgen_anon_1: WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_INTERNAL_ACTIVITY_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn StartupSuspend(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StartupSuspend(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HaltSuspend(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HaltSuspend(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IdleSuspend(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IdleSuspend(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        StartupSuspend: UINT64,
        HaltSuspend: UINT64,
        IdleSuspend: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let StartupSuspend: u64 = unsafe { ::std::mem::transmute(StartupSuspend) };
            StartupSuspend as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HaltSuspend: u64 = unsafe { ::std::mem::transmute(HaltSuspend) };
            HaltSuspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IdleSuspend: u64 = unsafe { ::std::mem::transmute(IdleSuspend) };
            IdleSuspend as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_INTERNAL_ACTIVITY_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_INTERNAL_ACTIVITY_REGISTER>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_INTERNAL_ACTIVITY_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_INTERNAL_ACTIVITY_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_INTERNAL_ACTIVITY_REGISTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_INTERNAL_ACTIVITY_REGISTER>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERNAL_ACTIVITY_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_INTERNAL_ACTIVITY_REGISTER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_DEBUG_EXCEPTION {
    pub AsUINT64: UINT64,
    pub __bindgen_anon_1: WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1)
        )
    );
}
impl WHV_X64_PENDING_DEBUG_EXCEPTION__bindgen_ty_1 {
    #[inline]
    pub fn Breakpoint0(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Breakpoint0(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Breakpoint1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Breakpoint1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Breakpoint2(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Breakpoint2(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Breakpoint3(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Breakpoint3(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SingleStep(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SingleStep(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Breakpoint0: UINT64,
        Breakpoint1: UINT64,
        Breakpoint2: UINT64,
        Breakpoint3: UINT64,
        SingleStep: UINT64,
        Reserved0: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Breakpoint0: u64 = unsafe { ::std::mem::transmute(Breakpoint0) };
            Breakpoint0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Breakpoint1: u64 = unsafe { ::std::mem::transmute(Breakpoint1) };
            Breakpoint1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Breakpoint2: u64 = unsafe { ::std::mem::transmute(Breakpoint2) };
            Breakpoint2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Breakpoint3: u64 = unsafe { ::std::mem::transmute(Breakpoint3) };
            Breakpoint3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SingleStep: u64 = unsafe { ::std::mem::transmute(SingleStep) };
            SingleStep as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved0: u64 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_DEBUG_EXCEPTION() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_DEBUG_EXCEPTION>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_DEBUG_EXCEPTION))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_DEBUG_EXCEPTION>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_PENDING_DEBUG_EXCEPTION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_DEBUG_EXCEPTION>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_DEBUG_EXCEPTION),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_PENDING_DEBUG_EXCEPTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_REGISTER_VALUE {
    pub Reg128: WHV_UINT128,
    pub Reg64: UINT64,
    pub Reg32: UINT32,
    pub Reg16: UINT16,
    pub Reg8: UINT8,
    pub Fp: WHV_X64_FP_REGISTER,
    pub FpControlStatus: WHV_X64_FP_CONTROL_STATUS_REGISTER,
    pub XmmControlStatus: WHV_X64_XMM_CONTROL_STATUS_REGISTER,
    pub Segment: WHV_X64_SEGMENT_REGISTER,
    pub Table: WHV_X64_TABLE_REGISTER,
    pub InterruptState: WHV_X64_INTERRUPT_STATE_REGISTER,
    pub PendingInterruption: WHV_X64_PENDING_INTERRUPTION_REGISTER,
    pub DeliverabilityNotifications: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER,
    pub ExceptionEvent: WHV_X64_PENDING_EXCEPTION_EVENT,
    pub ExtIntEvent: WHV_X64_PENDING_EXT_INT_EVENT,
    pub InternalActivity: WHV_INTERNAL_ACTIVITY_REGISTER,
    pub PendingDebugException: WHV_X64_PENDING_DEBUG_EXCEPTION,
}
#[test]
fn bindgen_test_layout_WHV_REGISTER_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_REGISTER_VALUE>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_REGISTER_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_REGISTER_VALUE>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_REGISTER_VALUE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg128)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).FpControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(FpControlStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).XmmControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(XmmControlStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).InterruptState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(InterruptState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).PendingInterruption as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(PendingInterruption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).DeliverabilityNotifications as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(DeliverabilityNotifications)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExceptionEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExceptionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExtIntEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExtIntEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).InternalActivity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(InternalActivity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).PendingDebugException as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(PendingDebugException)
        )
    );
}
impl Default for WHV_REGISTER_VALUE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonNone: WHV_RUN_VP_EXIT_REASON = 0;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonMemoryAccess: WHV_RUN_VP_EXIT_REASON = 1;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64IoPortAccess: WHV_RUN_VP_EXIT_REASON = 2;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnrecoverableException: WHV_RUN_VP_EXIT_REASON =
    4;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonInvalidVpRegisterValue: WHV_RUN_VP_EXIT_REASON =
    5;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnsupportedFeature: WHV_RUN_VP_EXIT_REASON = 6;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64InterruptWindow: WHV_RUN_VP_EXIT_REASON = 7;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Halt: WHV_RUN_VP_EXIT_REASON = 8;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicEoi: WHV_RUN_VP_EXIT_REASON = 9;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64MsrAccess: WHV_RUN_VP_EXIT_REASON = 4096;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Cpuid: WHV_RUN_VP_EXIT_REASON = 4097;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonException: WHV_RUN_VP_EXIT_REASON = 4098;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Rdtsc: WHV_RUN_VP_EXIT_REASON = 4099;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicSmiTrap: WHV_RUN_VP_EXIT_REASON = 4100;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonHypercall: WHV_RUN_VP_EXIT_REASON = 4101;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicInitSipiTrap: WHV_RUN_VP_EXIT_REASON =
    4102;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicWriteTrap: WHV_RUN_VP_EXIT_REASON = 4103;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonCanceled: WHV_RUN_VP_EXIT_REASON = 8193;
pub type WHV_RUN_VP_EXIT_REASON = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_VP_EXECUTION_STATE {
    pub __bindgen_anon_1: WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1,
    pub AsUINT16: UINT16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
}
impl WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    #[inline]
    pub fn Cpl(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Cpl(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Pe(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Pe(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Am(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Am(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EferLma(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EferLma(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugActive(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DebugActive(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionPending(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptShadow(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Cpl: UINT16,
        Cr0Pe: UINT16,
        Cr0Am: UINT16,
        EferLma: UINT16,
        DebugActive: UINT16,
        InterruptionPending: UINT16,
        Reserved0: UINT16,
        InterruptShadow: UINT16,
        Reserved1: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Cpl: u16 = unsafe { ::std::mem::transmute(Cpl) };
            Cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Cr0Pe: u16 = unsafe { ::std::mem::transmute(Cr0Pe) };
            Cr0Pe as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Cr0Am: u16 = unsafe { ::std::mem::transmute(Cr0Am) };
            Cr0Am as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EferLma: u16 = unsafe { ::std::mem::transmute(EferLma) };
            EferLma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DebugActive: u16 = unsafe { ::std::mem::transmute(DebugActive) };
            DebugActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let InterruptionPending: u16 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let Reserved0: u16 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InterruptShadow: u16 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved1: u16 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Size of: ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Alignment of ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_VP_EXECUTION_STATE>())).AsUINT16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE),
            "::",
            stringify!(AsUINT16)
        )
    );
}
impl Default for WHV_X64_VP_EXECUTION_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXIT_CONTEXT {
    pub ExecutionState: WHV_X64_VP_EXECUTION_STATE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Reserved: UINT8,
    pub Reserved2: UINT32,
    pub Cs: WHV_X64_SEGMENT_REGISTER,
    pub Rip: UINT64,
    pub Rflags: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXIT_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXIT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).ExecutionState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExecutionState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rflags)
        )
    );
}
impl Default for WHV_VP_EXIT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl WHV_VP_EXIT_CONTEXT {
    #[inline]
    pub fn InstructionLength(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr8(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Cr8(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InstructionLength: UINT8,
        Cr8: UINT8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let InstructionLength: u8 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Cr8: u8 = unsafe { ::std::mem::transmute(Cr8) };
            Cr8 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessRead: WHV_MEMORY_ACCESS_TYPE = 0;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessWrite: WHV_MEMORY_ACCESS_TYPE = 1;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessExecute: WHV_MEMORY_ACCESS_TYPE = 2;
pub type WHV_MEMORY_ACCESS_TYPE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_MEMORY_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_MEMORY_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn AccessType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AccessType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn GpaUnmapped(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GpaUnmapped(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GvaValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GvaValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AccessType: UINT32,
        GpaUnmapped: UINT32,
        GvaValid: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let AccessType: u32 = unsafe { ::std::mem::transmute(AccessType) };
            AccessType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GpaUnmapped: u32 = unsafe { ::std::mem::transmute(GpaUnmapped) };
            GpaUnmapped as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GvaValid: u32 = unsafe { ::std::mem::transmute(GvaValid) };
            GvaValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
impl Default for WHV_MEMORY_ACCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_MEMORY_ACCESS_INFO,
    pub Gpa: WHV_GUEST_PHYSICAL_ADDRESS,
    pub Gva: WHV_GUEST_VIRTUAL_ADDRESS,
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gpa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gva as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gva)
        )
    );
}
impl Default for WHV_MEMORY_ACCESS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_IO_PORT_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessSize(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AccessSize(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn StringOp(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StringOp(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RepPrefix(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RepPrefix(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        AccessSize: UINT32,
        StringOp: UINT32,
        RepPrefix: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let AccessSize: u32 = unsafe { ::std::mem::transmute(AccessSize) };
            AccessSize as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let StringOp: u32 = unsafe { ::std::mem::transmute(StringOp) };
            StringOp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RepPrefix: u32 = unsafe { ::std::mem::transmute(RepPrefix) };
            RepPrefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
impl Default for WHV_X64_IO_PORT_ACCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_X64_IO_PORT_ACCESS_INFO,
    pub PortNumber: UINT16,
    pub Reserved2: [UINT16; 3usize],
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rsi: UINT64,
    pub Rdi: UINT64,
    pub Ds: WHV_X64_SEGMENT_REGISTER,
    pub Es: WHV_X64_SEGMENT_REGISTER,
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        96usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionByteCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).AccessInfo as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).PortNumber as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(PortNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved2 as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rsi as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rdi as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Ds as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Es as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Es)
        )
    );
}
impl Default for WHV_X64_IO_PORT_ACCESS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_MSR_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
impl Default for WHV_X64_MSR_ACCESS_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_CONTEXT {
    pub AccessInfo: WHV_X64_MSR_ACCESS_INFO,
    pub MsrNumber: UINT32,
    pub Rax: UINT64,
    pub Rdx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).MsrNumber as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(MsrNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rdx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
}
impl Default for WHV_X64_MSR_ACCESS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_CPUID_ACCESS_CONTEXT {
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rdx: UINT64,
    pub Rbx: UINT64,
    pub DefaultResultRax: UINT64,
    pub DefaultResultRcx: UINT64,
    pub DefaultResultRdx: UINT64,
    pub DefaultResultRbx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        64usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rdx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rbx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRax as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRcx as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRdx as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRbx as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRbx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_VP_EXCEPTION_INFO {
    pub __bindgen_anon_1: WHV_VP_EXCEPTION_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    #[inline]
    pub fn ErrorCodeValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorCodeValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftwareException(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SoftwareException(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorCodeValid: UINT32,
        SoftwareException: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorCodeValid: u32 = unsafe { ::std::mem::transmute(ErrorCodeValid) };
            ErrorCodeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SoftwareException: u32 = unsafe { ::std::mem::transmute(SoftwareException) };
            SoftwareException as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXCEPTION_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
impl Default for WHV_VP_EXCEPTION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXCEPTION_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub ExceptionInfo: WHV_VP_EXCEPTION_INFO,
    pub ExceptionType: UINT8,
    pub Reserved2: [UINT8; 3usize],
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved2 as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ErrorCode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionParameter as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
impl Default for WHV_VP_EXCEPTION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureIntercept:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 1;
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureTaskSwitchTss:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 2;
pub type WHV_X64_UNSUPPORTED_FEATURE_CODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_UNSUPPORTED_FEATURE_CONTEXT {
    pub FeatureCode: WHV_X64_UNSUPPORTED_FEATURE_CODE,
    pub Reserved: UINT32,
    pub FeatureParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_UNSUPPORTED_FEATURE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).Reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureParameter
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureParameter)
        )
    );
}
impl Default for WHV_X64_UNSUPPORTED_FEATURE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_RUN_VP_CANCEL_REASON_WHvRunVpCancelReasonUser: WHV_RUN_VP_CANCEL_REASON = 0;
pub type WHV_RUN_VP_CANCEL_REASON = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_RUN_VP_CANCELED_CONTEXT {
    pub CancelReason: WHV_RUN_VP_CANCEL_REASON,
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_CANCELED_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_CANCELED_CONTEXT>())).CancelReason as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_CANCELED_CONTEXT),
            "::",
            stringify!(CancelReason)
        )
    );
}
impl Default for WHV_RUN_VP_CANCELED_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingInterrupt:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 0;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingNmi: WHV_X64_PENDING_INTERRUPTION_TYPE = 2;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingException:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 3;
pub type WHV_X64_PENDING_INTERRUPTION_TYPE = ::std::os::raw::c_int;
pub type PWHV_X64_PENDING_INTERRUPTION_TYPE = *mut WHV_X64_PENDING_INTERRUPTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT {
    pub DeliverableType: WHV_X64_PENDING_INTERRUPTION_TYPE,
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>())).DeliverableType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT),
            "::",
            stringify!(DeliverableType)
        )
    );
}
impl Default for WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PWHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT = *mut WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_APIC_EOI_CONTEXT {
    pub InterruptVector: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_EOI_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_EOI_CONTEXT>())).InterruptVector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_EOI_CONTEXT),
            "::",
            stringify!(InterruptVector)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_RDTSC_INFO {
    pub __bindgen_anon_1: WHV_X64_RDTSC_INFO__bindgen_ty_1,
    pub AsUINT64: UINT64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_RDTSC_INFO__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_WHV_X64_RDTSC_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_RDTSC_INFO__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_RDTSC_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_RDTSC_INFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_RDTSC_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_RDTSC_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsRdtscp(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IsRdtscp(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsRdtscp: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsRdtscp: u64 = unsafe { ::std::mem::transmute(IsRdtscp) };
            IsRdtscp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_RDTSC_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_RDTSC_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_RDTSC_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_RDTSC_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_RDTSC_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_RDTSC_INFO>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_INFO),
            "::",
            stringify!(AsUINT64)
        )
    );
}
impl Default for WHV_X64_RDTSC_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_RDTSC_CONTEXT {
    pub TscAux: UINT64,
    pub VirtualOffset: UINT64,
    pub Tsc: UINT64,
    pub ReferenceTime: UINT64,
    pub RdtscInfo: WHV_X64_RDTSC_INFO,
}
#[test]
fn bindgen_test_layout_WHV_X64_RDTSC_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_RDTSC_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_X64_RDTSC_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_RDTSC_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_RDTSC_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_RDTSC_CONTEXT>())).TscAux as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_CONTEXT),
            "::",
            stringify!(TscAux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_RDTSC_CONTEXT>())).VirtualOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_CONTEXT),
            "::",
            stringify!(VirtualOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_RDTSC_CONTEXT>())).Tsc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_CONTEXT),
            "::",
            stringify!(Tsc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_RDTSC_CONTEXT>())).ReferenceTime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_CONTEXT),
            "::",
            stringify!(ReferenceTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_RDTSC_CONTEXT>())).RdtscInfo as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_RDTSC_CONTEXT),
            "::",
            stringify!(RdtscInfo)
        )
    );
}
impl Default for WHV_X64_RDTSC_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_APIC_SMI_CONTEXT {
    pub ApicIcr: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_SMI_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_SMI_CONTEXT>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_SMI_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_SMI_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_SMI_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_SMI_CONTEXT>())).ApicIcr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_SMI_CONTEXT),
            "::",
            stringify!(ApicIcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _WHV_HYPERCALL_CONTEXT {
    pub Rax: UINT64,
    pub Rbx: UINT64,
    pub Rcx: UINT64,
    pub Rdx: UINT64,
    pub R8: UINT64,
    pub Rsi: UINT64,
    pub Rdi: UINT64,
    pub Reserved0: UINT64,
    pub XmmRegisters: [WHV_UINT128; 6usize],
    pub Reserved1: [UINT64; 2usize],
}
#[test]
fn bindgen_test_layout__WHV_HYPERCALL_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_HYPERCALL_CONTEXT>(),
        176usize,
        concat!("Size of: ", stringify!(_WHV_HYPERCALL_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_HYPERCALL_CONTEXT>(),
        16usize,
        concat!("Alignment of ", stringify!(_WHV_HYPERCALL_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rax as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rbx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rcx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rdx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).R8 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(R8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rsi as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Rdi as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Reserved0 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Reserved0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).XmmRegisters as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(XmmRegisters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_HYPERCALL_CONTEXT>())).Reserved1 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_HYPERCALL_CONTEXT),
            "::",
            stringify!(Reserved1)
        )
    );
}
impl Default for _WHV_HYPERCALL_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type WHV_HYPERCALL_CONTEXT = _WHV_HYPERCALL_CONTEXT;
pub type PWHV_HYPERCALL_CONTEXT = *mut _WHV_HYPERCALL_CONTEXT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_X64_APIC_INIT_SIPI_CONTEXT {
    pub ApicIcr: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_INIT_SIPI_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_INIT_SIPI_CONTEXT>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_INIT_SIPI_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_INIT_SIPI_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_INIT_SIPI_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_INIT_SIPI_CONTEXT>())).ApicIcr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_INIT_SIPI_CONTEXT),
            "::",
            stringify!(ApicIcr)
        )
    );
}
pub const WHV_X64_APIC_WRITE_TYPE_WHvX64ApicWriteTypeSvr: WHV_X64_APIC_WRITE_TYPE = 240;
pub const WHV_X64_APIC_WRITE_TYPE_WHvX64ApicWriteTypeLint0: WHV_X64_APIC_WRITE_TYPE = 848;
pub const WHV_X64_APIC_WRITE_TYPE_WHvX64ApicWriteTypeLint1: WHV_X64_APIC_WRITE_TYPE = 864;
pub type WHV_X64_APIC_WRITE_TYPE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_APIC_WRITE_CONTEXT {
    pub Type: WHV_X64_APIC_WRITE_TYPE,
    pub Reserved: UINT32,
    pub WriteValue: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_WRITE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_WRITE_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_WRITE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_WRITE_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_WRITE_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_APIC_WRITE_CONTEXT>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_WRITE_CONTEXT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_WRITE_CONTEXT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_WRITE_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_WRITE_CONTEXT>())).WriteValue as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_WRITE_CONTEXT),
            "::",
            stringify!(WriteValue)
        )
    );
}
impl Default for WHV_X64_APIC_WRITE_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct WHV_RUN_VP_EXIT_CONTEXT {
    pub ExitReason: WHV_RUN_VP_EXIT_REASON,
    pub Reserved: UINT32,
    pub VpContext: WHV_VP_EXIT_CONTEXT,
    pub __bindgen_anon_1: WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1 {
    pub MemoryAccess: WHV_MEMORY_ACCESS_CONTEXT,
    pub IoPortAccess: WHV_X64_IO_PORT_ACCESS_CONTEXT,
    pub MsrAccess: WHV_X64_MSR_ACCESS_CONTEXT,
    pub CpuidAccess: WHV_X64_CPUID_ACCESS_CONTEXT,
    pub VpException: WHV_VP_EXCEPTION_CONTEXT,
    pub InterruptWindow: WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT,
    pub UnsupportedFeature: WHV_X64_UNSUPPORTED_FEATURE_CONTEXT,
    pub CancelReason: WHV_RUN_VP_CANCELED_CONTEXT,
    pub ApicEoi: WHV_X64_APIC_EOI_CONTEXT,
    pub ReadTsc: WHV_X64_RDTSC_CONTEXT,
    pub ApicSmi: WHV_X64_APIC_SMI_CONTEXT,
    pub Hypercall: WHV_HYPERCALL_CONTEXT,
    pub ApicInitSipi: WHV_X64_APIC_INIT_SIPI_CONTEXT,
    pub ApicWrite: WHV_X64_APIC_WRITE_CONTEXT,
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        176usize,
        concat!(
            "Size of: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MemoryAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MemoryAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).IoPortAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(IoPortAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MsrAccess as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MsrAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CpuidAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CpuidAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).VpException
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(VpException)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).InterruptWindow
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(InterruptWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).UnsupportedFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(UnsupportedFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CancelReason
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CancelReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicEoi as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicEoi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ReadTsc as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ReadTsc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicSmi as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicSmi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).Hypercall as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(Hypercall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicInitSipi
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicInitSipi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicWrite as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicWrite)
        )
    );
}
impl Default for WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        224usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        16usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).ExitReason as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExitReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).VpContext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(VpContext)
        )
    );
}
impl Default for WHV_RUN_VP_EXIT_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeFixed: WHV_INTERRUPT_TYPE = 0;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLowestPriority: WHV_INTERRUPT_TYPE = 1;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeNmi: WHV_INTERRUPT_TYPE = 4;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeInit: WHV_INTERRUPT_TYPE = 5;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeSipi: WHV_INTERRUPT_TYPE = 6;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLocalInt1: WHV_INTERRUPT_TYPE = 9;
pub type WHV_INTERRUPT_TYPE = ::std::os::raw::c_int;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModePhysical:
    WHV_INTERRUPT_DESTINATION_MODE = 0;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModeLogical:
    WHV_INTERRUPT_DESTINATION_MODE = 1;
pub type WHV_INTERRUPT_DESTINATION_MODE = ::std::os::raw::c_int;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeEdge: WHV_INTERRUPT_TRIGGER_MODE = 0;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeLevel: WHV_INTERRUPT_TRIGGER_MODE =
    1;
pub type WHV_INTERRUPT_TRIGGER_MODE = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_INTERRUPT_CONTROL {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub Destination: UINT32,
    pub Vector: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_INTERRUPT_CONTROL() {
    assert_eq!(
        ::std::mem::size_of::<WHV_INTERRUPT_CONTROL>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_INTERRUPT_CONTROL>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Destination as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Vector as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Vector)
        )
    );
}
impl WHV_INTERRUPT_CONTROL {
    #[inline]
    pub fn Type(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DestinationMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_DestinationMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn TriggerMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_TriggerMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: UINT64,
        DestinationMode: UINT64,
        TriggerMode: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let DestinationMode: u64 = unsafe { ::std::mem::transmute(DestinationMode) };
            DestinationMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let TriggerMode: u64 = unsafe { ::std::mem::transmute(TriggerMode) };
            TriggerMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_DOORBELL_MATCH_DATA {
    pub GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
    pub Value: UINT64,
    pub Length: UINT32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_DOORBELL_MATCH_DATA() {
    assert_eq!(
        ::std::mem::size_of::<WHV_DOORBELL_MATCH_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_DOORBELL_MATCH_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_DOORBELL_MATCH_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_DOORBELL_MATCH_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_DOORBELL_MATCH_DATA>())).GuestAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_DOORBELL_MATCH_DATA),
            "::",
            stringify!(GuestAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_DOORBELL_MATCH_DATA>())).Value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_DOORBELL_MATCH_DATA),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_DOORBELL_MATCH_DATA>())).Length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_DOORBELL_MATCH_DATA),
            "::",
            stringify!(Length)
        )
    );
}
impl WHV_DOORBELL_MATCH_DATA {
    #[inline]
    pub fn MatchOnValue(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MatchOnValue(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MatchOnLength(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MatchOnLength(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MatchOnValue: UINT32,
        MatchOnLength: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MatchOnValue: u32 = unsafe { ::std::mem::transmute(MatchOnValue) };
            MatchOnValue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MatchOnLength: u32 = unsafe { ::std::mem::transmute(MatchOnLength) };
            MatchOnLength as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_PARTITION_COUNTER_SET_WHvPartitionCounterSetMemory: WHV_PARTITION_COUNTER_SET = 0;
pub type WHV_PARTITION_COUNTER_SET = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PARTITION_MEMORY_COUNTERS {
    pub Mapped4KPageCount: UINT64,
    pub Mapped2MPageCount: UINT64,
    pub Mapped1GPageCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_MEMORY_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped4KPageCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped4KPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped2MPageCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped2MPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped1GPageCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped1GPageCount)
        )
    );
}
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetRuntime: WHV_PROCESSOR_COUNTER_SET = 0;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetIntercepts: WHV_PROCESSOR_COUNTER_SET = 1;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetEvents: WHV_PROCESSOR_COUNTER_SET = 2;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetApic: WHV_PROCESSOR_COUNTER_SET = 3;
pub type WHV_PROCESSOR_COUNTER_SET = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_RUNTIME_COUNTERS {
    pub TotalRuntime100ns: UINT64,
    pub HypervisorRuntime100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_RUNTIME_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).TotalRuntime100ns as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(TotalRuntime100ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).HypervisorRuntime100ns
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(HypervisorRuntime100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTER {
    pub Count: UINT64,
    pub Time100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Time100ns as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Time100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTERS {
    pub PageInvalidations: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub ControlRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub IoInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub HaltInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub CpuidInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub MsrAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub OtherIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PendingInterrupts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub EmulatedInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub DebugRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PageFaultIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        176usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageInvalidations
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageInvalidations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).ControlRegisterAccesses
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(ControlRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).IoInstructions as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(IoInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).HaltInstructions
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(HaltInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).CpuidInstructions
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(CpuidInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).MsrAccesses as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(MsrAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).OtherIntercepts as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(OtherIntercepts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PendingInterrupts
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PendingInterrupts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).EmulatedInstructions
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(EmulatedInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).DebugRegisterAccesses
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(DebugRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageFaultIntercepts
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageFaultIntercepts)
        )
    );
}
pub type WHV_PROCESSOR_ACTIVITY_COUNTERS = WHV_PROCESSOR_INTERCEPT_COUNTERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_EVENT_COUNTERS {
    pub PageFaultCount: UINT64,
    pub ExceptionCount: UINT64,
    pub InterruptCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_EVENT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).PageFaultCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(PageFaultCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).ExceptionCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(ExceptionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).InterruptCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(InterruptCount)
        )
    );
}
pub type WHV_PROCESSOR_GUEST_EVENT_COUNTERS = WHV_PROCESSOR_EVENT_COUNTERS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_PROCESSOR_APIC_COUNTERS {
    pub MmioAccessCount: UINT64,
    pub EoiAccessCount: UINT64,
    pub TprAccessCount: UINT64,
    pub SentIpiCount: UINT64,
    pub SelfIpiCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_APIC_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).MmioAccessCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(MmioAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).EoiAccessCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(EoiAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).TprAccessCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(TprAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SentIpiCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SentIpiCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SelfIpiCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SelfIpiCount)
        )
    );
}
pub type HRESULT = ::std::os::raw::c_long;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_EMULATOR_STATUS {
    pub __bindgen_anon_1: WHV_EMULATOR_STATUS__bindgen_ty_1,
    pub AsUINT32: UINT32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_EMULATOR_STATUS__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WHV_EMULATOR_STATUS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EMULATOR_STATUS__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_EMULATOR_STATUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EMULATOR_STATUS__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_EMULATOR_STATUS__bindgen_ty_1)
        )
    );
}
impl WHV_EMULATOR_STATUS__bindgen_ty_1 {
    #[inline]
    pub fn EmulationSuccessful(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EmulationSuccessful(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InternalEmulationFailure(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InternalEmulationFailure(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IoPortCallbackFailed(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IoPortCallbackFailed(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MemoryCallbackFailed(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MemoryCallbackFailed(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TranslateGvaPageCallbackFailed(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TranslateGvaPageCallbackFailed(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TranslateGvaPageCallbackGpaIsNotAligned(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TranslateGvaPageCallbackGpaIsNotAligned(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GetVirtualProcessorRegistersCallbackFailed(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GetVirtualProcessorRegistersCallbackFailed(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetVirtualProcessorRegistersCallbackFailed(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetVirtualProcessorRegistersCallbackFailed(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptCausedIntercept(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptCausedIntercept(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuestCannotBeFaulted(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuestCannotBeFaulted(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EmulationSuccessful: UINT32,
        InternalEmulationFailure: UINT32,
        IoPortCallbackFailed: UINT32,
        MemoryCallbackFailed: UINT32,
        TranslateGvaPageCallbackFailed: UINT32,
        TranslateGvaPageCallbackGpaIsNotAligned: UINT32,
        GetVirtualProcessorRegistersCallbackFailed: UINT32,
        SetVirtualProcessorRegistersCallbackFailed: UINT32,
        InterruptCausedIntercept: UINT32,
        GuestCannotBeFaulted: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EmulationSuccessful: u32 = unsafe { ::std::mem::transmute(EmulationSuccessful) };
            EmulationSuccessful as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InternalEmulationFailure: u32 =
                unsafe { ::std::mem::transmute(InternalEmulationFailure) };
            InternalEmulationFailure as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IoPortCallbackFailed: u32 = unsafe { ::std::mem::transmute(IoPortCallbackFailed) };
            IoPortCallbackFailed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MemoryCallbackFailed: u32 = unsafe { ::std::mem::transmute(MemoryCallbackFailed) };
            MemoryCallbackFailed as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TranslateGvaPageCallbackFailed: u32 =
                unsafe { ::std::mem::transmute(TranslateGvaPageCallbackFailed) };
            TranslateGvaPageCallbackFailed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TranslateGvaPageCallbackGpaIsNotAligned: u32 =
                unsafe { ::std::mem::transmute(TranslateGvaPageCallbackGpaIsNotAligned) };
            TranslateGvaPageCallbackGpaIsNotAligned as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GetVirtualProcessorRegistersCallbackFailed: u32 =
                unsafe { ::std::mem::transmute(GetVirtualProcessorRegistersCallbackFailed) };
            GetVirtualProcessorRegistersCallbackFailed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SetVirtualProcessorRegistersCallbackFailed: u32 =
                unsafe { ::std::mem::transmute(SetVirtualProcessorRegistersCallbackFailed) };
            SetVirtualProcessorRegistersCallbackFailed as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let InterruptCausedIntercept: u32 =
                unsafe { ::std::mem::transmute(InterruptCausedIntercept) };
            InterruptCausedIntercept as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GuestCannotBeFaulted: u32 = unsafe { ::std::mem::transmute(GuestCannotBeFaulted) };
            GuestCannotBeFaulted as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_EMULATOR_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EMULATOR_STATUS>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_EMULATOR_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EMULATOR_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_EMULATOR_STATUS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EMULATOR_STATUS>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_STATUS),
            "::",
            stringify!(AsUINT32)
        )
    );
}
impl Default for WHV_EMULATOR_STATUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_EMULATOR_MEMORY_ACCESS_INFO {
    pub GpaAddress: WHV_GUEST_PHYSICAL_ADDRESS,
    pub Direction: UINT8,
    pub AccessSize: UINT8,
    pub Data: [UINT8; 8usize],
}
#[test]
fn bindgen_test_layout_WHV_EMULATOR_MEMORY_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EMULATOR_MEMORY_ACCESS_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EMULATOR_MEMORY_ACCESS_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_MEMORY_ACCESS_INFO>())).GpaAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO),
            "::",
            stringify!(GpaAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_MEMORY_ACCESS_INFO>())).Direction as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_MEMORY_ACCESS_INFO>())).AccessSize as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO),
            "::",
            stringify!(AccessSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_MEMORY_ACCESS_INFO>())).Data as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_MEMORY_ACCESS_INFO),
            "::",
            stringify!(Data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct WHV_EMULATOR_IO_ACCESS_INFO {
    pub Direction: UINT8,
    pub Port: UINT16,
    pub AccessSize: UINT16,
    pub Data: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_EMULATOR_IO_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EMULATOR_IO_ACCESS_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(WHV_EMULATOR_IO_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EMULATOR_IO_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_EMULATOR_IO_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_IO_ACCESS_INFO>())).Direction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_IO_ACCESS_INFO),
            "::",
            stringify!(Direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_IO_ACCESS_INFO>())).Port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_IO_ACCESS_INFO),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_IO_ACCESS_INFO>())).AccessSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_IO_ACCESS_INFO),
            "::",
            stringify!(AccessSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_IO_ACCESS_INFO>())).Data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_IO_ACCESS_INFO),
            "::",
            stringify!(Data)
        )
    );
}
pub type WHV_EMULATOR_IO_PORT_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        Context: *mut ::std::os::raw::c_void,
        IoAccess: *mut WHV_EMULATOR_IO_ACCESS_INFO,
    ) -> HRESULT,
>;
pub type WHV_EMULATOR_MEMORY_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        Context: *mut ::std::os::raw::c_void,
        MemoryAccess: *mut WHV_EMULATOR_MEMORY_ACCESS_INFO,
    ) -> HRESULT,
>;
pub type WHV_EMULATOR_GET_VIRTUAL_PROCESSOR_REGISTERS_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        Context: *mut ::std::os::raw::c_void,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *mut WHV_REGISTER_VALUE,
    ) -> HRESULT,
>;
pub type WHV_EMULATOR_SET_VIRTUAL_PROCESSOR_REGISTERS_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        Context: *mut ::std::os::raw::c_void,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *const WHV_REGISTER_VALUE,
    ) -> HRESULT,
>;
pub type WHV_EMULATOR_TRANSLATE_GVA_PAGE_CALLBACK = ::std::option::Option<
    unsafe extern "stdcall" fn(
        Context: *mut ::std::os::raw::c_void,
        Gva: WHV_GUEST_VIRTUAL_ADDRESS,
        TranslateFlags: WHV_TRANSLATE_GVA_FLAGS,
        TranslationResult: *mut WHV_TRANSLATE_GVA_RESULT_CODE,
        Gpa: *mut WHV_GUEST_PHYSICAL_ADDRESS,
    ) -> HRESULT,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_EMULATOR_CALLBACKS {
    pub Size: UINT32,
    pub Reserved: UINT32,
    pub WHvEmulatorIoPortCallback: WHV_EMULATOR_IO_PORT_CALLBACK,
    pub WHvEmulatorMemoryCallback: WHV_EMULATOR_MEMORY_CALLBACK,
    pub WHvEmulatorGetVirtualProcessorRegisters:
        WHV_EMULATOR_GET_VIRTUAL_PROCESSOR_REGISTERS_CALLBACK,
    pub WHvEmulatorSetVirtualProcessorRegisters:
        WHV_EMULATOR_SET_VIRTUAL_PROCESSOR_REGISTERS_CALLBACK,
    pub WHvEmulatorTranslateGvaPage: WHV_EMULATOR_TRANSLATE_GVA_PAGE_CALLBACK,
}
#[test]
fn bindgen_test_layout_WHV_EMULATOR_CALLBACKS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EMULATOR_CALLBACKS>(),
        48usize,
        concat!("Size of: ", stringify!(WHV_EMULATOR_CALLBACKS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EMULATOR_CALLBACKS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_EMULATOR_CALLBACKS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>())).WHvEmulatorIoPortCallback as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(WHvEmulatorIoPortCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>())).WHvEmulatorMemoryCallback as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(WHvEmulatorMemoryCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>()))
                .WHvEmulatorGetVirtualProcessorRegisters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(WHvEmulatorGetVirtualProcessorRegisters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>()))
                .WHvEmulatorSetVirtualProcessorRegisters as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(WHvEmulatorSetVirtualProcessorRegisters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_EMULATOR_CALLBACKS>())).WHvEmulatorTranslateGvaPage
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EMULATOR_CALLBACKS),
            "::",
            stringify!(WHvEmulatorTranslateGvaPage)
        )
    );
}
pub type WHV_EMULATOR_HANDLE = *mut ::std::os::raw::c_void;
#[link(name = "WinHvEmulation")]
#[allow(improper_ctypes)]
extern "stdcall" {
    pub fn WHvEmulatorCreateEmulator(
        Callbacks: *const WHV_EMULATOR_CALLBACKS,
        Emulator: *mut WHV_EMULATOR_HANDLE,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvEmulatorDestroyEmulator(Emulator: WHV_EMULATOR_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvEmulatorTryIoEmulation(
        Emulator: WHV_EMULATOR_HANDLE,
        Context: *mut ::std::os::raw::c_void,
        VpContext: *const WHV_VP_EXIT_CONTEXT,
        IoInstructionContext: *const WHV_X64_IO_PORT_ACCESS_CONTEXT,
        EmulatorReturnStatus: *mut WHV_EMULATOR_STATUS,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvEmulatorTryMmioEmulation(
        Emulator: WHV_EMULATOR_HANDLE,
        Context: *mut ::std::os::raw::c_void,
        VpContext: *const WHV_VP_EXIT_CONTEXT,
        MmioInstructionContext: *const WHV_MEMORY_ACCESS_CONTEXT,
        EmulatorReturnStatus: *mut WHV_EMULATOR_STATUS,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn IsWHvEmulatorCreateEmulatorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvEmulatorDestroyEmulatorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvEmulatorTryIoEmulationPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvEmulatorTryMmioEmulationPresent() -> BOOLEAN;
}
#[link(name = "WinHvPlatform")]
extern "stdcall" {
    pub fn WHvGetCapability(
        CapabilityCode: WHV_CAPABILITY_CODE,
        CapabilityBuffer: *mut ::std::os::raw::c_void,
        CapabilityBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvCreatePartition(Partition: *mut WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSetupPartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvDeletePartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *mut ::std::os::raw::c_void,
        PropertyBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *const ::std::os::raw::c_void,
        PropertyBufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSuspendPartitionTime(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvResumePartitionTime(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvMapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        SourceAddress: *mut ::std::os::raw::c_void,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
        Flags: WHV_MAP_GPA_RANGE_FLAGS,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvUnmapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvTranslateGva(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Gva: WHV_GUEST_VIRTUAL_ADDRESS,
        TranslateFlags: WHV_TRANSLATE_GVA_FLAGS,
        TranslationResult: *mut WHV_TRANSLATE_GVA_RESULT,
        Gpa: *mut WHV_GUEST_PHYSICAL_ADDRESS,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvCreateVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvDeleteVirtualProcessor(Partition: WHV_PARTITION_HANDLE, VpIndex: UINT32) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        ExitContext: *mut ::std::os::raw::c_void,
        ExitContextSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvCancelRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
#[allow(improper_ctypes)]
extern "stdcall" {
    pub fn WHvGetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *mut WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
#[allow(improper_ctypes)]
extern "stdcall" {
    pub fn WHvSetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *const WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *mut ::std::os::raw::c_void,
        StateSize: UINT32,
        WrittenSize: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *const ::std::os::raw::c_void,
        StateSize: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvRequestInterrupt(
        Partition: WHV_PARTITION_HANDLE,
        Interrupt: *const WHV_INTERRUPT_CONTROL,
        InterruptControlSize: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *const ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvQueryGpaRangeDirtyBitmap(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        RangeSizeInBytes: UINT64,
        Bitmap: *mut UINT64,
        BitmapSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetPartitionCounters(
        Partition: WHV_PARTITION_HANDLE,
        CounterSet: WHV_PARTITION_COUNTER_SET,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetVirtualProcessorCounters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        CounterSet: WHV_PROCESSOR_COUNTER_SET,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvGetVirtualProcessorInterruptControllerState2(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *mut ::std::os::raw::c_void,
        StateSize: UINT32,
        WrittenSize: *mut UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvSetVirtualProcessorInterruptControllerState2(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *const ::std::os::raw::c_void,
        StateSize: UINT32,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvRegisterPartitionDoorbellEvent(
        Partition: WHV_PARTITION_HANDLE,
        MatchData: *const WHV_DOORBELL_MATCH_DATA,
        EventHandle: HANDLE,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn WHvUnregisterPartitionDoorbellEvent(
        Partition: WHV_PARTITION_HANDLE,
        MatchData: *const WHV_DOORBELL_MATCH_DATA,
    ) -> HRESULT;
}
extern "stdcall" {
    pub fn IsWHvGetCapabilityPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvCreatePartitionPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetupPartitionPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvDeletePartitionPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetPartitionPropertyPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetPartitionPropertyPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSuspendPartitionTimePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvResumePartitionTimePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvMapGpaRangePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvUnmapGpaRangePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvTranslateGvaPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvCreateVirtualProcessorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvDeleteVirtualProcessorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvRunVirtualProcessorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvCancelRunVirtualProcessorPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetVirtualProcessorRegistersPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetVirtualProcessorRegistersPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetVirtualProcessorInterruptControllerStatePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetVirtualProcessorInterruptControllerStatePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvRequestInterruptPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetVirtualProcessorXsaveStatePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetVirtualProcessorXsaveStatePresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvQueryGpaRangeDirtyBitmapPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetPartitionCountersPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetVirtualProcessorCountersPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvGetVirtualProcessorInterruptControllerState2Present() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvSetVirtualProcessorInterruptControllerState2Present() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvRegisterPartitionDoorbellEventPresent() -> BOOLEAN;
}
extern "stdcall" {
    pub fn IsWHvUnregisterPartitionDoorbellEventPresent() -> BOOLEAN;
}
