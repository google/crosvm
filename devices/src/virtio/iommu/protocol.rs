// Copyright 2022 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! This file was generated by the following commands and modified manually.
//!
//! ```shell
//! $ bindgen virtio_iommu.h              \
//!     --allowlist-type "virtio_iommu.*" \
//!     --allowlist-var "VIRTIO_IOMMU_.*" \
//!     --with-derive-default            \
//!     --no-layout-tests                \
//!     --no-prepend-enum-name > protocol.rs
//! $ sed -i "s/__u/u/g" protocol.rs
//! $ sed -i "s/__le/Le/g" protocol.rs
//!
//! The main points of the manual modifications are as follows:
//! * Removed `head` and `tail` from each command struct. Instead, we process
//!   them as separate payloads.
//! * Added implementations of DataInit for each struct.
//! * Use of `packed` because removing `head` and `tail` introduces paddings
//! * Remove `IncompleteArrayField`
//! * Convert padding of [u8; 64usize] to [u64; 8usize]. According to the rust
//!   doc, "Arrays of sizes from 0 to 32 (inclusive) implement the Default trait
//!   if the element type allows it."

#![cfg_attr(windows, allow(dead_code))]
#![allow(non_camel_case_types)]

use data_model::DataInit;
use data_model::Le16;
use data_model::Le32;
use data_model::Le64;
use zerocopy::AsBytes;
use zerocopy::FromBytes;

pub const VIRTIO_IOMMU_F_INPUT_RANGE: u32 = 0;
pub const VIRTIO_IOMMU_F_DOMAIN_RANGE: u32 = 1;
pub const VIRTIO_IOMMU_F_MAP_UNMAP: u32 = 2;
pub const VIRTIO_IOMMU_F_BYPASS: u32 = 3;
pub const VIRTIO_IOMMU_F_PROBE: u32 = 4;
pub const VIRTIO_IOMMU_F_MMIO: u32 = 5;
pub const VIRTIO_IOMMU_T_ATTACH: u8 = 1;
pub const VIRTIO_IOMMU_T_DETACH: u8 = 2;
pub const VIRTIO_IOMMU_T_MAP: u8 = 3;
pub const VIRTIO_IOMMU_T_UNMAP: u8 = 4;
pub const VIRTIO_IOMMU_T_PROBE: u8 = 5;
pub const VIRTIO_IOMMU_S_OK: u8 = 0;
pub const VIRTIO_IOMMU_S_IOERR: u8 = 1;
pub const VIRTIO_IOMMU_S_UNSUPP: u8 = 2;
pub const VIRTIO_IOMMU_S_DEVERR: u8 = 3;
pub const VIRTIO_IOMMU_S_INVAL: u8 = 4;
pub const VIRTIO_IOMMU_S_RANGE: u8 = 5;
pub const VIRTIO_IOMMU_S_NOENT: u8 = 6;
pub const VIRTIO_IOMMU_S_FAULT: u8 = 7;
pub const VIRTIO_IOMMU_S_NOMEM: u8 = 8;
pub const VIRTIO_IOMMU_MAP_F_READ: u32 = 1;
pub const VIRTIO_IOMMU_MAP_F_WRITE: u32 = 2;
pub const VIRTIO_IOMMU_MAP_F_MMIO: u32 = 4;
pub const VIRTIO_IOMMU_MAP_F_MASK: u32 = 7;
pub const VIRTIO_IOMMU_PROBE_T_NONE: u32 = 0;
pub const VIRTIO_IOMMU_PROBE_T_RESV_MEM: u32 = 1;
pub const VIRTIO_IOMMU_PROBE_T_MASK: u32 = 4095;
pub const VIRTIO_IOMMU_RESV_MEM_T_RESERVED: u32 = 0;
pub const VIRTIO_IOMMU_RESV_MEM_T_MSI: u32 = 1;
pub const VIRTIO_IOMMU_FAULT_R_UNKNOWN: u32 = 0;
pub const VIRTIO_IOMMU_FAULT_R_DOMAIN: u32 = 1;
pub const VIRTIO_IOMMU_FAULT_R_MAPPING: u32 = 2;
pub const VIRTIO_IOMMU_FAULT_F_READ: u32 = 1;
pub const VIRTIO_IOMMU_FAULT_F_WRITE: u32 = 2;
pub const VIRTIO_IOMMU_FAULT_F_EXEC: u32 = 4;
pub const VIRTIO_IOMMU_FAULT_F_ADDRESS: u32 = 256;

#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_range_64 {
    pub start: Le64,
    pub end: Le64,
}
unsafe impl DataInit for virtio_iommu_range_64 {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_range_32 {
    pub start: Le32,
    pub end: Le32,
}
unsafe impl DataInit for virtio_iommu_range_32 {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_config {
    pub page_size_mask: Le64,
    pub input_range: virtio_iommu_range_64,
    pub domain_range: virtio_iommu_range_32,
    pub probe_size: Le32,
}
unsafe impl DataInit for virtio_iommu_config {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_head {
    pub type_: u8,
    pub reserved: [u8; 3usize],
}
unsafe impl DataInit for virtio_iommu_req_head {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_req_tail {
    pub status: u8,
    pub reserved: [u8; 3usize],
}
unsafe impl DataInit for virtio_iommu_req_tail {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_attach {
    pub domain: Le32,
    pub endpoint: Le32,
    pub reserved: [u8; 8usize],
}
unsafe impl DataInit for virtio_iommu_req_attach {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_detach {
    pub domain: Le32,
    pub endpoint: Le32,
    pub reserved: [u8; 8usize],
}
unsafe impl DataInit for virtio_iommu_req_detach {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_map {
    pub domain: Le32,
    pub virt_start: Le64,
    pub virt_end: Le64,
    pub phys_start: Le64,
    pub flags: Le32,
}
unsafe impl DataInit for virtio_iommu_req_map {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_unmap {
    pub domain: Le32,
    pub virt_start: Le64,
    pub virt_end: Le64,
    pub reserved: [u8; 4usize],
}
unsafe impl DataInit for virtio_iommu_req_unmap {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_probe_property {
    pub type_: Le16,
    pub length: Le16,
}
unsafe impl DataInit for virtio_iommu_probe_property {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_probe_resv_mem {
    pub head: virtio_iommu_probe_property,
    pub subtype: u8,
    pub reserved: [u8; 3usize],
    pub start: Le64,
    pub end: Le64,
}
unsafe impl DataInit for virtio_iommu_probe_resv_mem {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, AsBytes, FromBytes)]
pub struct virtio_iommu_req_probe {
    pub endpoint: Le32,
    pub reserved: [u64; 8usize],
}
unsafe impl DataInit for virtio_iommu_req_probe {}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct virtio_iommu_fault {
    pub reason: u8,
    pub reserved: [u8; 3usize],
    pub flags: Le32,
    pub endpoint: Le32,
    pub reserved2: [u8; 4usize],
    pub address: Le64,
}
unsafe impl DataInit for virtio_iommu_fault {}
