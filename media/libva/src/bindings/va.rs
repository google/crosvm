/* automatically generated by tools/bindgen-all-the-things */

#![allow(clippy::missing_safety_doc)]
#![allow(clippy::upper_case_acronyms)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub mod constants;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type VADisplay = *mut ::std::os::raw::c_void;
pub type VAStatus = ::std::os::raw::c_int;
extern "C" {
    pub fn vaErrorStr(error_status: VAStatus) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAMotionVector {
    pub mv0: [i16; 2usize],
    pub mv1: [i16; 2usize],
}
pub type VAMotionVector = _VAMotionVector;
pub type VAMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        user_context: *mut ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn vaSetErrorCallback(
        dpy: VADisplay,
        callback: VAMessageCallback,
        user_context: *mut ::std::os::raw::c_void,
    ) -> VAMessageCallback;
}
extern "C" {
    pub fn vaSetInfoCallback(
        dpy: VADisplay,
        callback: VAMessageCallback,
        user_context: *mut ::std::os::raw::c_void,
    ) -> VAMessageCallback;
}
extern "C" {
    pub fn vaDisplayIsValid(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaSetDriverName(dpy: VADisplay, driver_name: *mut ::std::os::raw::c_char) -> VAStatus;
}
extern "C" {
    pub fn vaInitialize(
        dpy: VADisplay,
        major_version: *mut ::std::os::raw::c_int,
        minor_version: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaTerminate(dpy: VADisplay) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVendorString(dpy: VADisplay) -> *const ::std::os::raw::c_char;
}
pub type VAPrivFunc = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn vaGetLibFunc(dpy: VADisplay, func: *const ::std::os::raw::c_char) -> VAPrivFunc;
}
pub mod VAProfile {
    pub type Type = ::std::os::raw::c_int;
    pub const VAProfileNone: Type = -1;
    pub const VAProfileMPEG2Simple: Type = 0;
    pub const VAProfileMPEG2Main: Type = 1;
    pub const VAProfileMPEG4Simple: Type = 2;
    pub const VAProfileMPEG4AdvancedSimple: Type = 3;
    pub const VAProfileMPEG4Main: Type = 4;
    pub const VAProfileH264Baseline: Type = 5;
    pub const VAProfileH264Main: Type = 6;
    pub const VAProfileH264High: Type = 7;
    pub const VAProfileVC1Simple: Type = 8;
    pub const VAProfileVC1Main: Type = 9;
    pub const VAProfileVC1Advanced: Type = 10;
    pub const VAProfileH263Baseline: Type = 11;
    pub const VAProfileJPEGBaseline: Type = 12;
    pub const VAProfileH264ConstrainedBaseline: Type = 13;
    pub const VAProfileVP8Version0_3: Type = 14;
    pub const VAProfileH264MultiviewHigh: Type = 15;
    pub const VAProfileH264StereoHigh: Type = 16;
    pub const VAProfileHEVCMain: Type = 17;
    pub const VAProfileHEVCMain10: Type = 18;
    pub const VAProfileVP9Profile0: Type = 19;
    pub const VAProfileVP9Profile1: Type = 20;
    pub const VAProfileVP9Profile2: Type = 21;
    pub const VAProfileVP9Profile3: Type = 22;
    pub const VAProfileHEVCMain12: Type = 23;
    pub const VAProfileHEVCMain422_10: Type = 24;
    pub const VAProfileHEVCMain422_12: Type = 25;
    pub const VAProfileHEVCMain444: Type = 26;
    pub const VAProfileHEVCMain444_10: Type = 27;
    pub const VAProfileHEVCMain444_12: Type = 28;
    pub const VAProfileHEVCSccMain: Type = 29;
    pub const VAProfileHEVCSccMain10: Type = 30;
    pub const VAProfileHEVCSccMain444: Type = 31;
    pub const VAProfileAV1Profile0: Type = 32;
    pub const VAProfileAV1Profile1: Type = 33;
    pub const VAProfileHEVCSccMain444_10: Type = 34;
    pub const VAProfileProtected: Type = 35;
}
pub mod VAEntrypoint {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEntrypointVLD: Type = 1;
    pub const VAEntrypointIZZ: Type = 2;
    pub const VAEntrypointIDCT: Type = 3;
    pub const VAEntrypointMoComp: Type = 4;
    pub const VAEntrypointDeblocking: Type = 5;
    pub const VAEntrypointEncSlice: Type = 6;
    pub const VAEntrypointEncPicture: Type = 7;
    pub const VAEntrypointEncSliceLP: Type = 8;
    pub const VAEntrypointVideoProc: Type = 10;
    pub const VAEntrypointFEI: Type = 11;
    pub const VAEntrypointStats: Type = 12;
    pub const VAEntrypointProtectedTEEComm: Type = 13;
    pub const VAEntrypointProtectedContent: Type = 14;
}
pub mod VAConfigAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAConfigAttribRTFormat: Type = 0;
    pub const VAConfigAttribSpatialResidual: Type = 1;
    pub const VAConfigAttribSpatialClipping: Type = 2;
    pub const VAConfigAttribIntraResidual: Type = 3;
    pub const VAConfigAttribEncryption: Type = 4;
    pub const VAConfigAttribRateControl: Type = 5;
    pub const VAConfigAttribDecSliceMode: Type = 6;
    pub const VAConfigAttribDecJPEG: Type = 7;
    pub const VAConfigAttribDecProcessing: Type = 8;
    pub const VAConfigAttribEncPackedHeaders: Type = 10;
    pub const VAConfigAttribEncInterlaced: Type = 11;
    pub const VAConfigAttribEncMaxRefFrames: Type = 13;
    pub const VAConfigAttribEncMaxSlices: Type = 14;
    pub const VAConfigAttribEncSliceStructure: Type = 15;
    pub const VAConfigAttribEncMacroblockInfo: Type = 16;
    pub const VAConfigAttribMaxPictureWidth: Type = 18;
    pub const VAConfigAttribMaxPictureHeight: Type = 19;
    pub const VAConfigAttribEncJPEG: Type = 20;
    pub const VAConfigAttribEncQualityRange: Type = 21;
    pub const VAConfigAttribEncQuantization: Type = 22;
    pub const VAConfigAttribEncIntraRefresh: Type = 23;
    pub const VAConfigAttribEncSkipFrame: Type = 24;
    pub const VAConfigAttribEncROI: Type = 25;
    pub const VAConfigAttribEncRateControlExt: Type = 26;
    pub const VAConfigAttribProcessingRate: Type = 27;
    pub const VAConfigAttribEncDirtyRect: Type = 28;
    pub const VAConfigAttribEncParallelRateControl: Type = 29;
    pub const VAConfigAttribEncDynamicScaling: Type = 30;
    pub const VAConfigAttribFrameSizeToleranceSupport: Type = 31;
    pub const VAConfigAttribFEIFunctionType: Type = 32;
    pub const VAConfigAttribFEIMVPredictors: Type = 33;
    pub const VAConfigAttribStats: Type = 34;
    pub const VAConfigAttribEncTileSupport: Type = 35;
    pub const VAConfigAttribCustomRoundingControl: Type = 36;
    pub const VAConfigAttribQPBlockSize: Type = 37;
    pub const VAConfigAttribMaxFrameSize: Type = 38;
    pub const VAConfigAttribPredictionDirection: Type = 39;
    pub const VAConfigAttribMultipleFrame: Type = 40;
    pub const VAConfigAttribContextPriority: Type = 41;
    pub const VAConfigAttribDecAV1Features: Type = 42;
    pub const VAConfigAttribTEEType: Type = 43;
    pub const VAConfigAttribTEETypeClient: Type = 44;
    pub const VAConfigAttribProtectedContentCipherAlgorithm: Type = 45;
    pub const VAConfigAttribProtectedContentCipherBlockSize: Type = 46;
    pub const VAConfigAttribProtectedContentCipherMode: Type = 47;
    pub const VAConfigAttribProtectedContentCipherSampleType: Type = 48;
    pub const VAConfigAttribProtectedContentUsage: Type = 49;
    pub const VAConfigAttribEncHEVCFeatures: Type = 50;
    pub const VAConfigAttribEncHEVCBlockSizes: Type = 51;
    pub const VAConfigAttribEncAV1: Type = 52;
    pub const VAConfigAttribEncAV1Ext1: Type = 53;
    pub const VAConfigAttribEncAV1Ext2: Type = 54;
    pub const VAConfigAttribEncPerBlockControl: Type = 55;
    pub const VAConfigAttribTypeMax: Type = 56;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAConfigAttrib {
    pub type_: VAConfigAttribType::Type,
    pub value: u32,
}
impl Default for _VAConfigAttrib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAConfigAttrib = _VAConfigAttrib;
extern "C" {
    pub fn vaMaxNumProfiles(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaMaxNumEntrypoints(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaMaxNumConfigAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryConfigProfiles(
        dpy: VADisplay,
        profile_list: *mut VAProfile::Type,
        num_profiles: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryConfigEntrypoints(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint_list: *mut VAEntrypoint::Type,
        num_entrypoints: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetConfigAttributes(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint: VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub type VAGenericID = ::std::os::raw::c_uint;
pub type VAConfigID = VAGenericID;
extern "C" {
    pub fn vaCreateConfig(
        dpy: VADisplay,
        profile: VAProfile::Type,
        entrypoint: VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: ::std::os::raw::c_int,
        config_id: *mut VAConfigID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyConfig(dpy: VADisplay, config_id: VAConfigID) -> VAStatus;
}
extern "C" {
    pub fn vaQueryConfigAttributes(
        dpy: VADisplay,
        config_id: VAConfigID,
        profile: *mut VAProfile::Type,
        entrypoint: *mut VAEntrypoint::Type,
        attrib_list: *mut VAConfigAttrib,
        num_attribs: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub type VAContextID = VAGenericID;
pub type VASurfaceID = VAGenericID;
pub mod VAGenericValueType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAGenericValueTypeInteger: Type = 1;
    pub const VAGenericValueTypeFloat: Type = 2;
    pub const VAGenericValueTypePointer: Type = 3;
    pub const VAGenericValueTypeFunc: Type = 4;
}
pub type VAGenericFunc = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAGenericValue {
    pub type_: VAGenericValueType::Type,
    pub value: _VAGenericValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAGenericValue__bindgen_ty_1 {
    pub i: i32,
    pub f: f32,
    pub p: *mut ::std::os::raw::c_void,
    pub fn_: VAGenericFunc,
}
impl Default for _VAGenericValue__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAGenericValue {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAGenericValue = _VAGenericValue;
pub mod VASurfaceAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VASurfaceAttribNone: Type = 0;
    pub const VASurfaceAttribPixelFormat: Type = 1;
    pub const VASurfaceAttribMinWidth: Type = 2;
    pub const VASurfaceAttribMaxWidth: Type = 3;
    pub const VASurfaceAttribMinHeight: Type = 4;
    pub const VASurfaceAttribMaxHeight: Type = 5;
    pub const VASurfaceAttribMemoryType: Type = 6;
    pub const VASurfaceAttribExternalBufferDescriptor: Type = 7;
    pub const VASurfaceAttribUsageHint: Type = 8;
    pub const VASurfaceAttribDRMFormatModifiers: Type = 9;
    pub const VASurfaceAttribCount: Type = 10;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASurfaceAttrib {
    pub type_: VASurfaceAttribType::Type,
    pub flags: u32,
    pub value: VAGenericValue,
}
impl Default for _VASurfaceAttrib {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASurfaceAttrib = _VASurfaceAttrib;
extern "C" {
    pub fn vaQuerySurfaceAttributes(
        dpy: VADisplay,
        config: VAConfigID,
        attrib_list: *mut VASurfaceAttrib,
        num_attribs: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateSurfaces(
        dpy: VADisplay,
        format: ::std::os::raw::c_uint,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_uint,
        attrib_list: *mut VASurfaceAttrib,
        num_attribs: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroySurfaces(
        dpy: VADisplay,
        surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateContext(
        dpy: VADisplay,
        config_id: VAConfigID,
        picture_width: ::std::os::raw::c_int,
        picture_height: ::std::os::raw::c_int,
        flag: ::std::os::raw::c_int,
        render_targets: *mut VASurfaceID,
        num_render_targets: ::std::os::raw::c_int,
        context: *mut VAContextID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyContext(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
pub type VAMFContextID = VAGenericID;
extern "C" {
    pub fn vaCreateMFContext(dpy: VADisplay, mf_context: *mut VAMFContextID) -> VAStatus;
}
extern "C" {
    pub fn vaMFAddContext(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        context: VAContextID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaMFReleaseContext(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        context: VAContextID,
    ) -> VAStatus;
}
pub type VABufferID = VAGenericID;
pub mod VABufferType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAPictureParameterBufferType: Type = 0;
    pub const VAIQMatrixBufferType: Type = 1;
    pub const VABitPlaneBufferType: Type = 2;
    pub const VASliceGroupMapBufferType: Type = 3;
    pub const VASliceParameterBufferType: Type = 4;
    pub const VASliceDataBufferType: Type = 5;
    pub const VAMacroblockParameterBufferType: Type = 6;
    pub const VAResidualDataBufferType: Type = 7;
    pub const VADeblockingParameterBufferType: Type = 8;
    pub const VAImageBufferType: Type = 9;
    pub const VAProtectedSliceDataBufferType: Type = 10;
    pub const VAQMatrixBufferType: Type = 11;
    pub const VAHuffmanTableBufferType: Type = 12;
    pub const VAProbabilityBufferType: Type = 13;
    pub const VAEncCodedBufferType: Type = 21;
    pub const VAEncSequenceParameterBufferType: Type = 22;
    pub const VAEncPictureParameterBufferType: Type = 23;
    pub const VAEncSliceParameterBufferType: Type = 24;
    pub const VAEncPackedHeaderParameterBufferType: Type = 25;
    pub const VAEncPackedHeaderDataBufferType: Type = 26;
    pub const VAEncMiscParameterBufferType: Type = 27;
    pub const VAEncMacroblockParameterBufferType: Type = 28;
    pub const VAEncMacroblockMapBufferType: Type = 29;
    pub const VAEncQPBufferType: Type = 30;
    pub const VAProcPipelineParameterBufferType: Type = 41;
    pub const VAProcFilterParameterBufferType: Type = 42;
    pub const VAEncFEIMVBufferType: Type = 43;
    pub const VAEncFEIMBCodeBufferType: Type = 44;
    pub const VAEncFEIDistortionBufferType: Type = 45;
    pub const VAEncFEIMBControlBufferType: Type = 46;
    pub const VAEncFEIMVPredictorBufferType: Type = 47;
    pub const VAStatsStatisticsParameterBufferType: Type = 48;
    pub const VAStatsStatisticsBufferType: Type = 49;
    pub const VAStatsStatisticsBottomFieldBufferType: Type = 50;
    pub const VAStatsMVBufferType: Type = 51;
    pub const VAStatsMVPredictorBufferType: Type = 52;
    pub const VAEncMacroblockDisableSkipMapBufferType: Type = 53;
    pub const VAEncFEICTBCmdBufferType: Type = 54;
    pub const VAEncFEICURecordBufferType: Type = 55;
    pub const VADecodeStreamoutBufferType: Type = 56;
    pub const VASubsetsParameterBufferType: Type = 57;
    pub const VAContextParameterUpdateBufferType: Type = 58;
    pub const VAProtectedSessionExecuteBufferType: Type = 59;
    pub const VAEncryptionParameterBufferType: Type = 60;
    pub const VAEncDeltaQpPerBlockBufferType: Type = 61;
    pub const VABufferTypeMax: Type = 62;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcessingRateParameterEnc {
    pub level_idc: u8,
    pub reserved: [u8; 3usize],
    pub quality_level: u32,
    pub intra_period: u32,
    pub ip_period: u32,
}
pub type VAProcessingRateParameterEnc = _VAProcessingRateParameterEnc;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcessingRateParameterDec {
    pub level_idc: u8,
    pub reserved0: [u8; 3usize],
    pub reserved: u32,
}
pub type VAProcessingRateParameterDec = _VAProcessingRateParameterDec;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAProcessingRateParameter {
    pub __bindgen_anon_1: _VAProcessingRateParameter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAProcessingRateParameter__bindgen_ty_1 {
    pub proc_buf_enc: VAProcessingRateParameterEnc,
    pub proc_buf_dec: VAProcessingRateParameterDec,
}
impl Default for _VAProcessingRateParameter__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAProcessingRateParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAProcessingRateParameter = _VAProcessingRateParameter;
extern "C" {
    pub fn vaQueryProcessingRate(
        dpy: VADisplay,
        config: VAConfigID,
        proc_buf: *mut VAProcessingRateParameter,
        processing_rate: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferMPEG2 {
    pub horizontal_size: u16,
    pub vertical_size: u16,
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub picture_coding_type: i32,
    pub f_code: i32,
    pub picture_coding_extension: _VAPictureParameterBufferMPEG2__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn picture_structure(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn top_field_first(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn q_scale_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alternate_scan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intra_dc_precision: u32,
        picture_structure: u32,
        top_field_first: u32,
        frame_pred_frame_dct: u32,
        concealment_motion_vectors: u32,
        q_scale_type: u32,
        intra_vlc_format: u32,
        alternate_scan: u32,
        repeat_first_field: u32,
        progressive_frame: u32,
        is_first_field: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let intra_dc_precision: u32 = unsafe { ::std::mem::transmute(intra_dc_precision) };
            intra_dc_precision as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let picture_structure: u32 = unsafe { ::std::mem::transmute(picture_structure) };
            picture_structure as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let top_field_first: u32 = unsafe { ::std::mem::transmute(top_field_first) };
            top_field_first as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frame_pred_frame_dct: u32 = unsafe { ::std::mem::transmute(frame_pred_frame_dct) };
            frame_pred_frame_dct as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let concealment_motion_vectors: u32 =
                unsafe { ::std::mem::transmute(concealment_motion_vectors) };
            concealment_motion_vectors as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let q_scale_type: u32 = unsafe { ::std::mem::transmute(q_scale_type) };
            q_scale_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intra_vlc_format: u32 = unsafe { ::std::mem::transmute(intra_vlc_format) };
            intra_vlc_format as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let alternate_scan: u32 = unsafe { ::std::mem::transmute(alternate_scan) };
            alternate_scan as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let repeat_first_field: u32 = unsafe { ::std::mem::transmute(repeat_first_field) };
            repeat_first_field as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let progressive_frame: u32 = unsafe { ::std::mem::transmute(progressive_frame) };
            progressive_frame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let is_first_field: u32 = unsafe { ::std::mem::transmute(is_first_field) };
            is_first_field as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferMPEG2 = _VAPictureParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferMPEG2 {
    pub load_intra_quantiser_matrix: i32,
    pub load_non_intra_quantiser_matrix: i32,
    pub load_chroma_intra_quantiser_matrix: i32,
    pub load_chroma_non_intra_quantiser_matrix: i32,
    pub intra_quantiser_matrix: [u8; 64usize],
    pub non_intra_quantiser_matrix: [u8; 64usize],
    pub chroma_intra_quantiser_matrix: [u8; 64usize],
    pub chroma_non_intra_quantiser_matrix: [u8; 64usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAIQMatrixBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAIQMatrixBufferMPEG2 = _VAIQMatrixBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferMPEG2 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub macroblock_offset: u32,
    pub slice_horizontal_position: u32,
    pub slice_vertical_position: u32,
    pub quantiser_scale_code: i32,
    pub intra_slice_flag: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferMPEG2 = _VASliceParameterBufferMPEG2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAMacroblockParameterBufferMPEG2 {
    pub macroblock_address: u16,
    pub macroblock_type: u8,
    pub macroblock_modes: _VAMacroblockParameterBufferMPEG2__bindgen_ty_1,
    pub motion_vertical_field_select: u8,
    pub PMV: [[[i16; 2usize]; 2usize]; 2usize],
    pub coded_block_pattern: u16,
    pub num_skipped_macroblocks: u16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _VAMacroblockParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frame_motion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_motion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn field_motion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_field_motion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dct_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dct_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_motion_type: u32,
        field_motion_type: u32,
        dct_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frame_motion_type: u32 = unsafe { ::std::mem::transmute(frame_motion_type) };
            frame_motion_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let field_motion_type: u32 = unsafe { ::std::mem::transmute(field_motion_type) };
            field_motion_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dct_type: u32 = unsafe { ::std::mem::transmute(dct_type) };
            dct_type as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAMacroblockParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAMacroblockParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAMacroblockParameterBufferMPEG2 = _VAMacroblockParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureH264 {
    pub picture_id: VASurfaceID,
    pub frame_idx: u32,
    pub flags: u32,
    pub TopFieldOrderCnt: i32,
    pub BottomFieldOrderCnt: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VAPictureH264 = _VAPictureH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub picture_width_in_mbs_minus1: u16,
    pub picture_height_in_mbs_minus1: u16,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub num_ref_frames: u8,
    pub seq_fields: _VAPictureParameterBufferH264__bindgen_ty_1,
    pub num_slice_groups_minus1: u8,
    pub slice_group_map_type: u8,
    pub slice_group_change_rate_minus1: u16,
    pub pic_init_qp_minus26: i8,
    pub pic_init_qs_minus26: i8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_fields: _VAPictureParameterBufferH264__bindgen_ty_2,
    pub frame_num: u16,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn residual_colour_transform_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_residual_colour_transform_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gaps_in_frame_num_value_allowed_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gaps_in_frame_num_value_allowed_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MinLumaBiPredSize8x8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MinLumaBiPredSize8x8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        residual_colour_transform_flag: u32,
        gaps_in_frame_num_value_allowed_flag: u32,
        frame_mbs_only_flag: u32,
        mb_adaptive_frame_field_flag: u32,
        direct_8x8_inference_flag: u32,
        MinLumaBiPredSize8x8: u32,
        log2_max_frame_num_minus4: u32,
        pic_order_cnt_type: u32,
        log2_max_pic_order_cnt_lsb_minus4: u32,
        delta_pic_order_always_zero_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let residual_colour_transform_flag: u32 =
                unsafe { ::std::mem::transmute(residual_colour_transform_flag) };
            residual_colour_transform_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gaps_in_frame_num_value_allowed_flag: u32 =
                unsafe { ::std::mem::transmute(gaps_in_frame_num_value_allowed_flag) };
            gaps_in_frame_num_value_allowed_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let frame_mbs_only_flag: u32 = unsafe { ::std::mem::transmute(frame_mbs_only_flag) };
            frame_mbs_only_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mb_adaptive_frame_field_flag: u32 =
                unsafe { ::std::mem::transmute(mb_adaptive_frame_field_flag) };
            mb_adaptive_frame_field_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let direct_8x8_inference_flag: u32 =
                unsafe { ::std::mem::transmute(direct_8x8_inference_flag) };
            direct_8x8_inference_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MinLumaBiPredSize8x8: u32 = unsafe { ::std::mem::transmute(MinLumaBiPredSize8x8) };
            MinLumaBiPredSize8x8 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let log2_max_frame_num_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_frame_num_minus4) };
            log2_max_frame_num_minus4 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let pic_order_cnt_type: u32 = unsafe { ::std::mem::transmute(pic_order_cnt_type) };
            pic_order_cnt_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 4u8, {
            let log2_max_pic_order_cnt_lsb_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_pic_order_cnt_lsb_minus4) };
            log2_max_pic_order_cnt_lsb_minus4 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let delta_pic_order_always_zero_flag: u32 =
                unsafe { ::std::mem::transmute(delta_pic_order_always_zero_flag) };
            delta_pic_order_always_zero_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferH264__bindgen_ty_2 {
    pub bits: _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAPictureParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        entropy_coding_mode_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_idc: u32,
        transform_8x8_mode_flag: u32,
        field_pic_flag: u32,
        constrained_intra_pred_flag: u32,
        pic_order_present_flag: u32,
        deblocking_filter_control_present_flag: u32,
        redundant_pic_cnt_present_flag: u32,
        reference_pic_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let entropy_coding_mode_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_mode_flag) };
            entropy_coding_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let weighted_bipred_idc: u32 = unsafe { ::std::mem::transmute(weighted_bipred_idc) };
            weighted_bipred_idc as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let transform_8x8_mode_flag: u32 =
                unsafe { ::std::mem::transmute(transform_8x8_mode_flag) };
            transform_8x8_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let field_pic_flag: u32 = unsafe { ::std::mem::transmute(field_pic_flag) };
            field_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pic_order_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_order_present_flag) };
            pic_order_present_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let deblocking_filter_control_present_flag: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_control_present_flag) };
            deblocking_filter_control_present_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let redundant_pic_cnt_present_flag: u32 =
                unsafe { ::std::mem::transmute(redundant_pic_cnt_present_flag) };
            redundant_pic_cnt_present_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reference_pic_flag: u32 = unsafe { ::std::mem::transmute(reference_pic_flag) };
            reference_pic_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferH264__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferH264 = _VAPictureParameterBufferH264;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferH264 {
    pub ScalingList4x4: [[u8; 16usize]; 6usize],
    pub ScalingList8x8: [[u8; 64usize]; 2usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAIQMatrixBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAIQMatrixBufferH264 = _VAIQMatrixBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferH264 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub slice_data_bit_offset: u16,
    pub first_mb_in_slice: u16,
    pub slice_type: u8,
    pub direct_spatial_mv_pred_flag: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub cabac_init_idc: u8,
    pub slice_qp_delta: i8,
    pub disable_deblocking_filter_idc: u8,
    pub slice_alpha_c0_offset_div2: i8,
    pub slice_beta_offset_div2: i8,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: u8,
    pub chroma_log2_weight_denom: u8,
    pub luma_weight_l0_flag: u8,
    pub luma_weight_l0: [i16; 32usize],
    pub luma_offset_l0: [i16; 32usize],
    pub chroma_weight_l0_flag: u8,
    pub chroma_weight_l0: [[i16; 2usize]; 32usize],
    pub chroma_offset_l0: [[i16; 2usize]; 32usize],
    pub luma_weight_l1_flag: u8,
    pub luma_weight_l1: [i16; 32usize],
    pub luma_offset_l1: [i16; 32usize],
    pub chroma_weight_l1_flag: u8,
    pub chroma_weight_l1: [[i16; 2usize]; 32usize],
    pub chroma_offset_l1: [[i16; 2usize]; 32usize],
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferH264 = _VASliceParameterBufferH264;
pub mod VAEncPictureType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPictureTypeIntra: Type = 0;
    pub const VAEncPictureTypePredictive: Type = 1;
    pub const VAEncPictureTypeBidirectional: Type = 2;
}
extern "C" {
    pub fn vaCreateBuffer(
        dpy: VADisplay,
        context: VAContextID,
        type_: VABufferType::Type,
        size: ::std::os::raw::c_uint,
        num_elements: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        buf_id: *mut VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateBuffer2(
        dpy: VADisplay,
        context: VAContextID,
        type_: VABufferType::Type,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        unit_size: *mut ::std::os::raw::c_uint,
        pitch: *mut ::std::os::raw::c_uint,
        buf_id: *mut VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaBufferSetNumElements(
        dpy: VADisplay,
        buf_id: VABufferID,
        num_elements: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaMapBuffer(
        dpy: VADisplay,
        buf_id: VABufferID,
        pbuf: *mut *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaUnmapBuffer(dpy: VADisplay, buf_id: VABufferID) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyBuffer(dpy: VADisplay, buffer_id: VABufferID) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct VABufferInfo {
    pub handle: usize,
    pub type_: u32,
    pub mem_type: u32,
    pub mem_size: usize,
    pub va_reserved: [u32; 4usize],
}
extern "C" {
    pub fn vaAcquireBufferHandle(
        dpy: VADisplay,
        buf_id: VABufferID,
        buf_info: *mut VABufferInfo,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaReleaseBufferHandle(dpy: VADisplay, buf_id: VABufferID) -> VAStatus;
}
extern "C" {
    pub fn vaExportSurfaceHandle(
        dpy: VADisplay,
        surface_id: VASurfaceID,
        mem_type: u32,
        flags: u32,
        descriptor: *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaBeginPicture(
        dpy: VADisplay,
        context: VAContextID,
        render_target: VASurfaceID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaRenderPicture(
        dpy: VADisplay,
        context: VAContextID,
        buffers: *mut VABufferID,
        num_buffers: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaEndPicture(dpy: VADisplay, context: VAContextID) -> VAStatus;
}
extern "C" {
    pub fn vaMFSubmit(
        dpy: VADisplay,
        mf_context: VAMFContextID,
        contexts: *mut VAContextID,
        num_contexts: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSyncSurface(dpy: VADisplay, render_target: VASurfaceID) -> VAStatus;
}
extern "C" {
    pub fn vaSyncSurface2(dpy: VADisplay, surface: VASurfaceID, timeout_ns: u64) -> VAStatus;
}
pub mod VASurfaceStatus {
    pub type Type = ::std::os::raw::c_uint;
    pub const VASurfaceRendering: Type = 1;
    pub const VASurfaceDisplaying: Type = 2;
    pub const VASurfaceReady: Type = 4;
    pub const VASurfaceSkipped: Type = 8;
}
extern "C" {
    pub fn vaQuerySurfaceStatus(
        dpy: VADisplay,
        render_target: VASurfaceID,
        status: *mut VASurfaceStatus::Type,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQuerySurfaceError(
        dpy: VADisplay,
        surface: VASurfaceID,
        error_status: VAStatus,
        error_info: *mut *mut ::std::os::raw::c_void,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSyncBuffer(dpy: VADisplay, buf_id: VABufferID, timeout_ns: u64) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAImageFormat {
    pub fourcc: u32,
    pub byte_order: u32,
    pub bits_per_pixel: u32,
    pub depth: u32,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub alpha_mask: u32,
    pub va_reserved: [u32; 4usize],
}
pub type VAImageFormat = _VAImageFormat;
pub type VAImageID = VAGenericID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAImage {
    pub image_id: VAImageID,
    pub format: VAImageFormat,
    pub buf: VABufferID,
    pub width: u16,
    pub height: u16,
    pub data_size: u32,
    pub num_planes: u32,
    pub pitches: [u32; 3usize],
    pub offsets: [u32; 3usize],
    pub num_palette_entries: i32,
    pub entry_bytes: i32,
    pub component_order: [i8; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAImage = _VAImage;
extern "C" {
    pub fn vaMaxNumImageFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryImageFormats(
        dpy: VADisplay,
        format_list: *mut VAImageFormat,
        num_formats: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateImage(
        dpy: VADisplay,
        format: *mut VAImageFormat,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        image: *mut VAImage,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyImage(dpy: VADisplay, image: VAImageID) -> VAStatus;
}
extern "C" {
    pub fn vaSetImagePalette(
        dpy: VADisplay,
        image: VAImageID,
        palette: *mut ::std::os::raw::c_uchar,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetImage(
        dpy: VADisplay,
        surface: VASurfaceID,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        image: VAImageID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaPutImage(
        dpy: VADisplay,
        surface: VASurfaceID,
        image: VAImageID,
        src_x: ::std::os::raw::c_int,
        src_y: ::std::os::raw::c_int,
        src_width: ::std::os::raw::c_uint,
        src_height: ::std::os::raw::c_uint,
        dest_x: ::std::os::raw::c_int,
        dest_y: ::std::os::raw::c_int,
        dest_width: ::std::os::raw::c_uint,
        dest_height: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDeriveImage(dpy: VADisplay, surface: VASurfaceID, image: *mut VAImage) -> VAStatus;
}
pub type VASubpictureID = VAGenericID;
extern "C" {
    pub fn vaMaxNumSubpictureFormats(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQuerySubpictureFormats(
        dpy: VADisplay,
        format_list: *mut VAImageFormat,
        flags: *mut ::std::os::raw::c_uint,
        num_formats: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaCreateSubpicture(
        dpy: VADisplay,
        image: VAImageID,
        subpicture: *mut VASubpictureID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroySubpicture(dpy: VADisplay, subpicture: VASubpictureID) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureImage(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        image: VAImageID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureChromakey(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        chromakey_min: ::std::os::raw::c_uint,
        chromakey_max: ::std::os::raw::c_uint,
        chromakey_mask: ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetSubpictureGlobalAlpha(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        global_alpha: f32,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaAssociateSubpicture(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        target_surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dest_x: i16,
        dest_y: i16,
        dest_width: u16,
        dest_height: u16,
        flags: u32,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDeassociateSubpicture(
        dpy: VADisplay,
        subpicture: VASubpictureID,
        target_surfaces: *mut VASurfaceID,
        num_surfaces: ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub mod VADisplayAttribType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VADisplayAttribBrightness: Type = 0;
    pub const VADisplayAttribContrast: Type = 1;
    pub const VADisplayAttribHue: Type = 2;
    pub const VADisplayAttribSaturation: Type = 3;
    pub const VADisplayAttribBackgroundColor: Type = 4;
    pub const VADisplayAttribDirectSurface: Type = 5;
    pub const VADisplayAttribRotation: Type = 6;
    pub const VADisplayAttribOutofLoopDeblock: Type = 7;
    pub const VADisplayAttribBLEBlackMode: Type = 8;
    pub const VADisplayAttribBLEWhiteMode: Type = 9;
    pub const VADisplayAttribBlueStretch: Type = 10;
    pub const VADisplayAttribSkinColorCorrection: Type = 11;
    pub const VADisplayAttribCSCMatrix: Type = 12;
    pub const VADisplayAttribBlendColor: Type = 13;
    pub const VADisplayAttribOverlayAutoPaintColorKey: Type = 14;
    pub const VADisplayAttribOverlayColorKey: Type = 15;
    pub const VADisplayAttribRenderMode: Type = 16;
    pub const VADisplayAttribRenderDevice: Type = 17;
    pub const VADisplayAttribRenderRect: Type = 18;
    pub const VADisplayAttribSubDevice: Type = 19;
    pub const VADisplayAttribCopy: Type = 20;
    pub const VADisplayPCIID: Type = 21;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VADisplayAttribute {
    pub type_: VADisplayAttribType::Type,
    pub min_value: i32,
    pub max_value: i32,
    pub value: i32,
    pub flags: u32,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VADisplayAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VADisplayAttribute = _VADisplayAttribute;
extern "C" {
    pub fn vaMaxNumDisplayAttributes(dpy: VADisplay) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vaQueryDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: *mut ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: ::std::os::raw::c_int,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaSetDisplayAttributes(
        dpy: VADisplay,
        attr_list: *mut VADisplayAttribute,
        num_attributes: ::std::os::raw::c_int,
    ) -> VAStatus;
}
pub mod VACopyObjectType {
    pub type Type = ::std::os::raw::c_uint;
    pub const VACopyObjectSurface: Type = 0;
    pub const VACopyObjectBuffer: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VACopyObject {
    pub obj_type: VACopyObjectType::Type,
    pub object: _VACopyObject__bindgen_ty_1,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACopyObject__bindgen_ty_1 {
    pub surface_id: VASurfaceID,
    pub buffer_id: VABufferID,
}
impl Default for _VACopyObject__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VACopyObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VACopyObject = _VACopyObject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VACopyOption {
    pub bits: _VACopyOption__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VACopyOption__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VACopyOption__bindgen_ty_1 {
    #[inline]
    pub fn va_copy_sync(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_va_copy_sync(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn va_copy_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_va_copy_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        va_copy_sync: u32,
        va_copy_mode: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let va_copy_sync: u32 = unsafe { ::std::mem::transmute(va_copy_sync) };
            va_copy_sync as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let va_copy_mode: u32 = unsafe { ::std::mem::transmute(va_copy_mode) };
            va_copy_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VACopyOption {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VACopyOption = _VACopyOption;
extern "C" {
    pub fn vaCopy(
        dpy: VADisplay,
        dst: *mut VACopyObject,
        src: *mut VACopyObject,
        option: VACopyOption,
    ) -> VAStatus;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VABoolCoderContextVPX {
    pub range: u8,
    pub value: u8,
    pub count: u8,
}
pub type VABoolCoderContextVPX = _VABoolCoderContextVPX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAPictureParameterBufferVP8 {
    pub frame_width: u32,
    pub frame_height: u32,
    pub last_ref_frame: VASurfaceID,
    pub golden_ref_frame: VASurfaceID,
    pub alt_ref_frame: VASurfaceID,
    pub out_of_loop_frame: VASurfaceID,
    pub pic_fields: _VAPictureParameterBufferVP8__bindgen_ty_1,
    pub mb_segment_tree_probs: [u8; 3usize],
    pub loop_filter_level: [u8; 4usize],
    pub loop_filter_deltas_ref_frame: [i8; 4usize],
    pub loop_filter_deltas_mode: [i8; 4usize],
    pub prob_skip_false: u8,
    pub prob_intra: u8,
    pub prob_last: u8,
    pub prob_gf: u8,
    pub y_mode_probs: [u8; 4usize],
    pub uv_mode_probs: [u8; 3usize],
    pub mv_probs: [[u8; 19usize]; 2usize],
    pub bool_coder_ctx: VABoolCoderContextVPX,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn key_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_key_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sharpness_level(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sharpness_level(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_ref_lf_delta_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mode_ref_lf_delta_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        key_frame: u32,
        version: u32,
        segmentation_enabled: u32,
        update_mb_segmentation_map: u32,
        update_segment_feature_data: u32,
        filter_type: u32,
        sharpness_level: u32,
        loop_filter_adj_enable: u32,
        mode_ref_lf_delta_update: u32,
        sign_bias_golden: u32,
        sign_bias_alternate: u32,
        mb_no_coeff_skip: u32,
        loop_filter_disable: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let key_frame: u32 = unsafe { ::std::mem::transmute(key_frame) };
            key_frame as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let update_mb_segmentation_map: u32 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_map) };
            update_mb_segmentation_map as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let update_segment_feature_data: u32 =
                unsafe { ::std::mem::transmute(update_segment_feature_data) };
            update_segment_feature_data as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let filter_type: u32 = unsafe { ::std::mem::transmute(filter_type) };
            filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let sharpness_level: u32 = unsafe { ::std::mem::transmute(sharpness_level) };
            sharpness_level as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let loop_filter_adj_enable: u32 =
                unsafe { ::std::mem::transmute(loop_filter_adj_enable) };
            loop_filter_adj_enable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mode_ref_lf_delta_update: u32 =
                unsafe { ::std::mem::transmute(mode_ref_lf_delta_update) };
            mode_ref_lf_delta_update as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let sign_bias_golden: u32 = unsafe { ::std::mem::transmute(sign_bias_golden) };
            sign_bias_golden as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let sign_bias_alternate: u32 = unsafe { ::std::mem::transmute(sign_bias_alternate) };
            sign_bias_alternate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let mb_no_coeff_skip: u32 = unsafe { ::std::mem::transmute(mb_no_coeff_skip) };
            mb_no_coeff_skip as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let loop_filter_disable: u32 = unsafe { ::std::mem::transmute(loop_filter_disable) };
            loop_filter_disable as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAPictureParameterBufferVP8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAPictureParameterBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAPictureParameterBufferVP8 = _VAPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASliceParameterBufferVP8 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub macroblock_offset: u32,
    pub num_of_partitions: u8,
    pub partition_size: [u32; 9usize],
    pub va_reserved: [u32; 4usize],
}
pub type VASliceParameterBufferVP8 = _VASliceParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAProbabilityDataBufferVP8 {
    pub dct_coeff_probs: [[[[u8; 11usize]; 3usize]; 8usize]; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAProbabilityDataBufferVP8 = _VAProbabilityDataBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAIQMatrixBufferVP8 {
    pub quantization_index: [[u16; 6usize]; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAIQMatrixBufferVP8 = _VAIQMatrixBufferVP8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VADecPictureParameterBufferVP9 {
    pub frame_width: u16,
    pub frame_height: u16,
    pub reference_frames: [VASurfaceID; 8usize],
    pub pic_fields: _VADecPictureParameterBufferVP9__bindgen_ty_1,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub frame_header_length_in_bytes: u8,
    pub first_partition_size: u16,
    pub mb_segment_tree_probs: [u8; 7usize],
    pub segment_pred_probs: [u8; 3usize],
    pub profile: u8,
    pub bit_depth: u8,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VADecPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subsampling_x(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_x(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn subsampling_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_subsampling_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_last_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn last_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn golden_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_golden_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn golden_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_golden_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alt_ref_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_alt_ref_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn alt_ref_frame_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alt_ref_frame_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lossless_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lossless_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        subsampling_x: u32,
        subsampling_y: u32,
        frame_type: u32,
        show_frame: u32,
        error_resilient_mode: u32,
        intra_only: u32,
        allow_high_precision_mv: u32,
        mcomp_filter_type: u32,
        frame_parallel_decoding_mode: u32,
        reset_frame_context: u32,
        refresh_frame_context: u32,
        frame_context_idx: u32,
        segmentation_enabled: u32,
        segmentation_temporal_update: u32,
        segmentation_update_map: u32,
        last_ref_frame: u32,
        last_ref_frame_sign_bias: u32,
        golden_ref_frame: u32,
        golden_ref_frame_sign_bias: u32,
        alt_ref_frame: u32,
        alt_ref_frame_sign_bias: u32,
        lossless_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let subsampling_x: u32 = unsafe { ::std::mem::transmute(subsampling_x) };
            subsampling_x as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let subsampling_y: u32 = unsafe { ::std::mem::transmute(subsampling_y) };
            subsampling_y as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let intra_only: u32 = unsafe { ::std::mem::transmute(intra_only) };
            intra_only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let mcomp_filter_type: u32 = unsafe { ::std::mem::transmute(mcomp_filter_type) };
            mcomp_filter_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let frame_parallel_decoding_mode: u32 =
                unsafe { ::std::mem::transmute(frame_parallel_decoding_mode) };
            frame_parallel_decoding_mode as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let reset_frame_context: u32 = unsafe { ::std::mem::transmute(reset_frame_context) };
            reset_frame_context as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let refresh_frame_context: u32 =
                unsafe { ::std::mem::transmute(refresh_frame_context) };
            refresh_frame_context as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let frame_context_idx: u32 = unsafe { ::std::mem::transmute(frame_context_idx) };
            frame_context_idx as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let segmentation_temporal_update: u32 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let segmentation_update_map: u32 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(19usize, 3u8, {
            let last_ref_frame: u32 = unsafe { ::std::mem::transmute(last_ref_frame) };
            last_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let last_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(last_ref_frame_sign_bias) };
            last_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(23usize, 3u8, {
            let golden_ref_frame: u32 = unsafe { ::std::mem::transmute(golden_ref_frame) };
            golden_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let golden_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(golden_ref_frame_sign_bias) };
            golden_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(27usize, 3u8, {
            let alt_ref_frame: u32 = unsafe { ::std::mem::transmute(alt_ref_frame) };
            alt_ref_frame as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let alt_ref_frame_sign_bias: u32 =
                unsafe { ::std::mem::transmute(alt_ref_frame_sign_bias) };
            alt_ref_frame_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let lossless_flag: u32 = unsafe { ::std::mem::transmute(lossless_flag) };
            lossless_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VADecPictureParameterBufferVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VADecPictureParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VADecPictureParameterBufferVP9 = _VADecPictureParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASegmentParameterVP9 {
    pub segment_flags: _VASegmentParameterVP9__bindgen_ty_1,
    pub filter_level: [[u8; 2usize]; 4usize],
    pub luma_ac_quant_scale: i16,
    pub luma_dc_quant_scale: i16,
    pub chroma_ac_quant_scale: i16,
    pub chroma_dc_quant_scale: i16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VASegmentParameterVP9__bindgen_ty_1 {
    pub fields: _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VASegmentParameterVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_reference_enabled: u16,
        segment_reference: u16,
        segment_reference_skipped: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segment_reference_enabled: u16 =
                unsafe { ::std::mem::transmute(segment_reference_enabled) };
            segment_reference_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let segment_reference: u16 = unsafe { ::std::mem::transmute(segment_reference) };
            segment_reference as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segment_reference_skipped: u16 =
                unsafe { ::std::mem::transmute(segment_reference_skipped) };
            segment_reference_skipped as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VASegmentParameterVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VASegmentParameterVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASegmentParameterVP9 = _VASegmentParameterVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VASliceParameterBufferVP9 {
    pub slice_data_size: u32,
    pub slice_data_offset: u32,
    pub slice_data_flag: u32,
    pub seg_param: [VASegmentParameterVP9; 8usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VASliceParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VASliceParameterBufferVP9 = _VASliceParameterBufferVP9;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAPictureStats {
    pub picture_id: VASurfaceID,
    pub flags: u32,
}
pub type VAPictureStats = _VAPictureStats;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsParameter {
    pub input: VAPictureStats,
    pub past_references: *mut VAPictureStats,
    pub num_past_references: u32,
    pub past_ref_stat_buf: *mut VABufferID,
    pub future_references: *mut VAPictureStats,
    pub num_future_references: u32,
    pub future_ref_stat_buf: *mut VABufferID,
    pub outputs: *mut VABufferID,
    pub mv_predictor: VABufferID,
    pub qp: VABufferID,
}
impl Default for _VAStatsStatisticsParameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAStatsStatisticsParameter = _VAStatsStatisticsParameter;
pub mod VAEncPackedHeaderTypeH264 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderH264_SPS: Type = 1;
    pub const VAEncPackedHeaderH264_PPS: Type = 2;
    pub const VAEncPackedHeaderH264_Slice: Type = 3;
    pub const VAEncPackedHeaderH264_SEI: Type = 2147483649;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferH264 {
    pub seq_parameter_set_id: u8,
    pub level_idc: u8,
    pub intra_period: u32,
    pub intra_idr_period: u32,
    pub ip_period: u32,
    pub bits_per_second: u32,
    pub max_num_ref_frames: u32,
    pub picture_width_in_mbs: u16,
    pub picture_height_in_mbs: u16,
    pub seq_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_1,
    pub bit_depth_luma_minus8: u8,
    pub bit_depth_chroma_minus8: u8,
    pub num_ref_frames_in_pic_order_cnt_cycle: u8,
    pub offset_for_non_ref_pic: i32,
    pub offset_for_top_to_bottom_field: i32,
    pub offset_for_ref_frame: [i32; 256usize],
    pub frame_cropping_flag: u8,
    pub frame_crop_left_offset: u32,
    pub frame_crop_right_offset: u32,
    pub frame_crop_top_offset: u32,
    pub frame_crop_bottom_offset: u32,
    pub vui_parameters_present_flag: u8,
    pub vui_fields: _VAEncSequenceParameterBufferH264__bindgen_ty_2,
    pub aspect_ratio_idc: u8,
    pub sar_width: u32,
    pub sar_height: u32,
    pub num_units_in_tick: u32,
    pub time_scale: u32,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn chroma_format_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_mbs_only_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_mbs_only_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_adaptive_frame_field_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_adaptive_frame_field_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn seq_scaling_matrix_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_seq_scaling_matrix_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_8x8_inference_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_direct_8x8_inference_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_frame_num_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_frame_num_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_cnt_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_cnt_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_pic_order_cnt_lsb_minus4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_pic_order_cnt_lsb_minus4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn delta_pic_order_always_zero_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_delta_pic_order_always_zero_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_format_idc: u32,
        frame_mbs_only_flag: u32,
        mb_adaptive_frame_field_flag: u32,
        seq_scaling_matrix_present_flag: u32,
        direct_8x8_inference_flag: u32,
        log2_max_frame_num_minus4: u32,
        pic_order_cnt_type: u32,
        log2_max_pic_order_cnt_lsb_minus4: u32,
        delta_pic_order_always_zero_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chroma_format_idc: u32 = unsafe { ::std::mem::transmute(chroma_format_idc) };
            chroma_format_idc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let frame_mbs_only_flag: u32 = unsafe { ::std::mem::transmute(frame_mbs_only_flag) };
            frame_mbs_only_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let mb_adaptive_frame_field_flag: u32 =
                unsafe { ::std::mem::transmute(mb_adaptive_frame_field_flag) };
            mb_adaptive_frame_field_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let seq_scaling_matrix_present_flag: u32 =
                unsafe { ::std::mem::transmute(seq_scaling_matrix_present_flag) };
            seq_scaling_matrix_present_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let direct_8x8_inference_flag: u32 =
                unsafe { ::std::mem::transmute(direct_8x8_inference_flag) };
            direct_8x8_inference_flag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let log2_max_frame_num_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_frame_num_minus4) };
            log2_max_frame_num_minus4 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let pic_order_cnt_type: u32 = unsafe { ::std::mem::transmute(pic_order_cnt_type) };
            pic_order_cnt_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let log2_max_pic_order_cnt_lsb_minus4: u32 =
                unsafe { ::std::mem::transmute(log2_max_pic_order_cnt_lsb_minus4) };
            log2_max_pic_order_cnt_lsb_minus4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let delta_pic_order_always_zero_flag: u32 =
                unsafe { ::std::mem::transmute(delta_pic_order_always_zero_flag) };
            delta_pic_order_always_zero_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    pub bits: _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferH264__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn aspect_ratio_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_aspect_ratio_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timing_info_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timing_info_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitstream_restriction_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bitstream_restriction_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_horizontal(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_horizontal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn log2_max_mv_length_vertical(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_log2_max_mv_length_vertical(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn fixed_frame_rate_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fixed_frame_rate_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn low_delay_hrd_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_low_delay_hrd_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn motion_vectors_over_pic_boundaries_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_motion_vectors_over_pic_boundaries_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        aspect_ratio_info_present_flag: u32,
        timing_info_present_flag: u32,
        bitstream_restriction_flag: u32,
        log2_max_mv_length_horizontal: u32,
        log2_max_mv_length_vertical: u32,
        fixed_frame_rate_flag: u32,
        low_delay_hrd_flag: u32,
        motion_vectors_over_pic_boundaries_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let aspect_ratio_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(aspect_ratio_info_present_flag) };
            aspect_ratio_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let timing_info_present_flag: u32 =
                unsafe { ::std::mem::transmute(timing_info_present_flag) };
            timing_info_present_flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bitstream_restriction_flag: u32 =
                unsafe { ::std::mem::transmute(bitstream_restriction_flag) };
            bitstream_restriction_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let log2_max_mv_length_horizontal: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_horizontal) };
            log2_max_mv_length_horizontal as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let log2_max_mv_length_vertical: u32 =
                unsafe { ::std::mem::transmute(log2_max_mv_length_vertical) };
            log2_max_mv_length_vertical as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let fixed_frame_rate_flag: u32 =
                unsafe { ::std::mem::transmute(fixed_frame_rate_flag) };
            fixed_frame_rate_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let low_delay_hrd_flag: u32 = unsafe { ::std::mem::transmute(low_delay_hrd_flag) };
            low_delay_hrd_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let motion_vectors_over_pic_boundaries_flag: u32 =
                unsafe { ::std::mem::transmute(motion_vectors_over_pic_boundaries_flag) };
            motion_vectors_over_pic_boundaries_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferH264__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferH264 = _VAEncSequenceParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferH264 {
    pub CurrPic: VAPictureH264,
    pub ReferenceFrames: [VAPictureH264; 16usize],
    pub coded_buf: VABufferID,
    pub pic_parameter_set_id: u8,
    pub seq_parameter_set_id: u8,
    pub last_picture: u8,
    pub frame_num: u16,
    pub pic_init_qp: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub chroma_qp_index_offset: i8,
    pub second_chroma_qp_index_offset: i8,
    pub pic_fields: _VAEncPictureParameterBufferH264__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncPictureParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn idr_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idr_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reference_pic_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reference_pic_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn entropy_coding_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entropy_coding_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn weighted_bipred_idc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_weighted_bipred_idc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn constrained_intra_pred_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_constrained_intra_pred_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_8x8_mode_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_8x8_mode_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deblocking_filter_control_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deblocking_filter_control_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redundant_pic_cnt_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_redundant_pic_cnt_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_order_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_order_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pic_scaling_matrix_present_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pic_scaling_matrix_present_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        idr_pic_flag: u32,
        reference_pic_flag: u32,
        entropy_coding_mode_flag: u32,
        weighted_pred_flag: u32,
        weighted_bipred_idc: u32,
        constrained_intra_pred_flag: u32,
        transform_8x8_mode_flag: u32,
        deblocking_filter_control_present_flag: u32,
        redundant_pic_cnt_present_flag: u32,
        pic_order_present_flag: u32,
        pic_scaling_matrix_present_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let idr_pic_flag: u32 = unsafe { ::std::mem::transmute(idr_pic_flag) };
            idr_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let reference_pic_flag: u32 = unsafe { ::std::mem::transmute(reference_pic_flag) };
            reference_pic_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let entropy_coding_mode_flag: u32 =
                unsafe { ::std::mem::transmute(entropy_coding_mode_flag) };
            entropy_coding_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let weighted_pred_flag: u32 = unsafe { ::std::mem::transmute(weighted_pred_flag) };
            weighted_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let weighted_bipred_idc: u32 = unsafe { ::std::mem::transmute(weighted_bipred_idc) };
            weighted_bipred_idc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let constrained_intra_pred_flag: u32 =
                unsafe { ::std::mem::transmute(constrained_intra_pred_flag) };
            constrained_intra_pred_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let transform_8x8_mode_flag: u32 =
                unsafe { ::std::mem::transmute(transform_8x8_mode_flag) };
            transform_8x8_mode_flag as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let deblocking_filter_control_present_flag: u32 =
                unsafe { ::std::mem::transmute(deblocking_filter_control_present_flag) };
            deblocking_filter_control_present_flag as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let redundant_pic_cnt_present_flag: u32 =
                unsafe { ::std::mem::transmute(redundant_pic_cnt_present_flag) };
            redundant_pic_cnt_present_flag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let pic_order_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_order_present_flag) };
            pic_order_present_flag as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let pic_scaling_matrix_present_flag: u32 =
                unsafe { ::std::mem::transmute(pic_scaling_matrix_present_flag) };
            pic_scaling_matrix_present_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferH264 = _VAEncPictureParameterBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncQPBufferH264 {
    pub qp: u8,
}
pub type VAEncQPBufferH264 = _VAEncQPBufferH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSliceParameterBufferH264 {
    pub macroblock_address: u32,
    pub num_macroblocks: u32,
    pub macroblock_info: VABufferID,
    pub slice_type: u8,
    pub pic_parameter_set_id: u8,
    pub idr_pic_id: u16,
    pub pic_order_cnt_lsb: u16,
    pub delta_pic_order_cnt_bottom: i32,
    pub delta_pic_order_cnt: [i32; 2usize],
    pub direct_spatial_mv_pred_flag: u8,
    pub num_ref_idx_active_override_flag: u8,
    pub num_ref_idx_l0_active_minus1: u8,
    pub num_ref_idx_l1_active_minus1: u8,
    pub RefPicList0: [VAPictureH264; 32usize],
    pub RefPicList1: [VAPictureH264; 32usize],
    pub luma_log2_weight_denom: u8,
    pub chroma_log2_weight_denom: u8,
    pub luma_weight_l0_flag: u8,
    pub luma_weight_l0: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l0: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l0_flag: u8,
    pub chroma_weight_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l0: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub luma_weight_l1_flag: u8,
    pub luma_weight_l1: [::std::os::raw::c_short; 32usize],
    pub luma_offset_l1: [::std::os::raw::c_short; 32usize],
    pub chroma_weight_l1_flag: u8,
    pub chroma_weight_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub chroma_offset_l1: [[::std::os::raw::c_short; 2usize]; 32usize],
    pub cabac_init_idc: u8,
    pub slice_qp_delta: i8,
    pub disable_deblocking_filter_idc: u8,
    pub slice_alpha_c0_offset_div2: i8,
    pub slice_beta_offset_div2: i8,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSliceParameterBufferH264 = _VAEncSliceParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMacroblockParameterBufferH264 {
    pub qp: u8,
    pub info: _VAEncMacroblockParameterBufferH264__bindgen_ty_1,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    pub intra_fields: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1,
    pub inter_fields: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn pred_avail_override_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pred_avail_override_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pred_avail_flags(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pred_avail_flags(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pred_avail_override_flag: u32,
        pred_avail_flags: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pred_avail_override_flag: u32 =
                unsafe { ::std::mem::transmute(pred_avail_override_flag) };
            pred_avail_override_flag as u64
        });
        __bindgen_bitfield_unit.set(1usize, 8u8, {
            let pred_avail_flags: u32 = unsafe { ::std::mem::transmute(pred_avail_flags) };
            pred_avail_flags as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2 {
    pub bits: _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub reserved: u32,
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMacroblockParameterBufferH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMacroblockParameterBufferH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMacroblockParameterBufferH264 = _VAEncMacroblockParameterBufferH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMiscParameterSubMbPartPelH264 {
    pub disable_inter_sub_mb_partition: u32,
    pub inter_sub_mb_partition_mask: _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1,
    pub enable_sub_pel_mode: u32,
    pub sub_pel_mode: u8,
    pub reserved: [u8; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1 {
    pub bits: _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1,
    pub value: u8,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn disable_16x16_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_16x16_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_16x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_16x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x16_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x16_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_8x4_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_8x4_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_4x8_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_4x8_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_4x4_inter_mb_partition(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_4x4_inter_mb_partition(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_16x16_inter_mb_partition: u32,
        disable_16x8_inter_mb_partition: u32,
        disable_8x16_inter_mb_partition: u32,
        disable_8x8_inter_mb_partition: u32,
        disable_8x4_inter_mb_partition: u32,
        disable_4x8_inter_mb_partition: u32,
        disable_4x4_inter_mb_partition: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_16x16_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_16x16_inter_mb_partition) };
            disable_16x16_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let disable_16x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_16x8_inter_mb_partition) };
            disable_16x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disable_8x16_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x16_inter_mb_partition) };
            disable_8x16_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let disable_8x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x8_inter_mb_partition) };
            disable_8x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disable_8x4_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_8x4_inter_mb_partition) };
            disable_8x4_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let disable_4x8_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_4x8_inter_mb_partition) };
            disable_4x8_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let disable_4x4_inter_mb_partition: u32 =
                unsafe { ::std::mem::transmute(disable_4x4_inter_mb_partition) };
            disable_4x4_inter_mb_partition as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncMiscParameterSubMbPartPelH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncMiscParameterSubMbPartPelH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMiscParameterSubMbPartPelH264 = _VAEncMiscParameterSubMbPartPelH264;
pub type VAQMatrixBufferMPEG2 = VAIQMatrixBufferMPEG2;
pub mod VAEncPackedHeaderTypeMPEG2 {
    pub type Type = ::std::os::raw::c_uint;
    pub const VAEncPackedHeaderMPEG2_SPS: Type = 1;
    pub const VAEncPackedHeaderMPEG2_PPS: Type = 2;
    pub const VAEncPackedHeaderMPEG2_Slice: Type = 3;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSequenceParameterBufferMPEG2 {
    pub intra_period: u32,
    pub ip_period: u32,
    pub picture_width: u16,
    pub picture_height: u16,
    pub bits_per_second: u32,
    pub frame_rate: f32,
    pub aspect_ratio_information: u16,
    pub vbv_buffer_size: u32,
    pub sequence_extension: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1,
    pub new_gop_header: u32,
    pub gop_header: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn profile_and_level_indication(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_profile_and_level_indication(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_sequence(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_sequence(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn low_delay(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_low_delay(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_rate_extension_n(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_rate_extension_n(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_rate_extension_d(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_frame_rate_extension_d(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        profile_and_level_indication: u32,
        progressive_sequence: u32,
        chroma_format: u32,
        low_delay: u32,
        frame_rate_extension_n: u32,
        frame_rate_extension_d: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let profile_and_level_indication: u32 =
                unsafe { ::std::mem::transmute(profile_and_level_indication) };
            profile_and_level_indication as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let progressive_sequence: u32 = unsafe { ::std::mem::transmute(progressive_sequence) };
            progressive_sequence as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let chroma_format: u32 = unsafe { ::std::mem::transmute(chroma_format) };
            chroma_format as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let low_delay: u32 = unsafe { ::std::mem::transmute(low_delay) };
            low_delay as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let frame_rate_extension_n: u32 =
                unsafe { ::std::mem::transmute(frame_rate_extension_n) };
            frame_rate_extension_n as u64
        });
        __bindgen_bitfield_unit.set(14usize, 5u8, {
            let frame_rate_extension_d: u32 =
                unsafe { ::std::mem::transmute(frame_rate_extension_d) };
            frame_rate_extension_d as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn time_code(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_time_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn closed_gop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_closed_gop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn broken_link(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_broken_link(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        time_code: u32,
        closed_gop: u32,
        broken_link: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 25u8, {
            let time_code: u32 = unsafe { ::std::mem::transmute(time_code) };
            time_code as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let closed_gop: u32 = unsafe { ::std::mem::transmute(closed_gop) };
            closed_gop as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let broken_link: u32 = unsafe { ::std::mem::transmute(broken_link) };
            broken_link as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSequenceParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSequenceParameterBufferMPEG2 = _VAEncSequenceParameterBufferMPEG2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferMPEG2 {
    pub forward_reference_picture: VASurfaceID,
    pub backward_reference_picture: VASurfaceID,
    pub reconstructed_picture: VASurfaceID,
    pub coded_buf: VABufferID,
    pub last_picture: u8,
    pub picture_type: VAEncPictureType::Type,
    pub temporal_reference: u32,
    pub vbv_delay: u32,
    pub f_code: [[u8; 2usize]; 2usize],
    pub picture_coding_extension: _VAEncPictureParameterBufferMPEG2__bindgen_ty_1,
    pub composite_display: _VAEncPictureParameterBufferMPEG2__bindgen_ty_2,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn intra_dc_precision(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_dc_precision(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn picture_structure(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_picture_structure(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn top_field_first(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_top_field_first(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_pred_frame_dct(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_pred_frame_dct(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn concealment_motion_vectors(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_concealment_motion_vectors(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn q_scale_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_q_scale_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_vlc_format(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_vlc_format(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alternate_scan(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_alternate_scan(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat_first_field(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repeat_first_field(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn progressive_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_progressive_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn composite_display_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_composite_display_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        intra_dc_precision: u32,
        picture_structure: u32,
        top_field_first: u32,
        frame_pred_frame_dct: u32,
        concealment_motion_vectors: u32,
        q_scale_type: u32,
        intra_vlc_format: u32,
        alternate_scan: u32,
        repeat_first_field: u32,
        progressive_frame: u32,
        composite_display_flag: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let intra_dc_precision: u32 = unsafe { ::std::mem::transmute(intra_dc_precision) };
            intra_dc_precision as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let picture_structure: u32 = unsafe { ::std::mem::transmute(picture_structure) };
            picture_structure as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let top_field_first: u32 = unsafe { ::std::mem::transmute(top_field_first) };
            top_field_first as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let frame_pred_frame_dct: u32 = unsafe { ::std::mem::transmute(frame_pred_frame_dct) };
            frame_pred_frame_dct as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let concealment_motion_vectors: u32 =
                unsafe { ::std::mem::transmute(concealment_motion_vectors) };
            concealment_motion_vectors as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let q_scale_type: u32 = unsafe { ::std::mem::transmute(q_scale_type) };
            q_scale_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let intra_vlc_format: u32 = unsafe { ::std::mem::transmute(intra_vlc_format) };
            intra_vlc_format as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let alternate_scan: u32 = unsafe { ::std::mem::transmute(alternate_scan) };
            alternate_scan as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let repeat_first_field: u32 = unsafe { ::std::mem::transmute(repeat_first_field) };
            repeat_first_field as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let progressive_frame: u32 = unsafe { ::std::mem::transmute(progressive_frame) };
            progressive_frame as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let composite_display_flag: u32 =
                unsafe { ::std::mem::transmute(composite_display_flag) };
            composite_display_flag as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl _VAEncPictureParameterBufferMPEG2__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn v_axis(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_v_axis(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_sequence(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_field_sequence(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_carrier(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sub_carrier(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn burst_amplitude(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_burst_amplitude(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_carrier_phase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_carrier_phase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        v_axis: u32,
        field_sequence: u32,
        sub_carrier: u32,
        burst_amplitude: u32,
        sub_carrier_phase: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let v_axis: u32 = unsafe { ::std::mem::transmute(v_axis) };
            v_axis as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let field_sequence: u32 = unsafe { ::std::mem::transmute(field_sequence) };
            field_sequence as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let sub_carrier: u32 = unsafe { ::std::mem::transmute(sub_carrier) };
            sub_carrier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let burst_amplitude: u32 = unsafe { ::std::mem::transmute(burst_amplitude) };
            burst_amplitude as u64
        });
        __bindgen_bitfield_unit.set(12usize, 8u8, {
            let sub_carrier_phase: u32 = unsafe { ::std::mem::transmute(sub_carrier_phase) };
            sub_carrier_phase as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferMPEG2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferMPEG2 = _VAEncPictureParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSliceParameterBufferMPEG2 {
    pub macroblock_address: u32,
    pub num_macroblocks: u32,
    pub quantiser_scale_code: i32,
    pub is_intra_slice: i32,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSliceParameterBufferMPEG2 = _VAEncSliceParameterBufferMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterExtensionDataSeqDisplayMPEG2 {
    pub extension_start_code_identifier: u8,
    pub video_format: u8,
    pub colour_description: u8,
    pub colour_primaries: u8,
    pub transfer_characteristics: u8,
    pub matrix_coefficients: u8,
    pub display_horizontal_size: u16,
    pub display_vertical_size: u16,
}
pub type VAEncMiscParameterExtensionDataSeqDisplayMPEG2 =
    _VAEncMiscParameterExtensionDataSeqDisplayMPEG2;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferVP8 {
    pub frame_width: u32,
    pub frame_height: u32,
    pub frame_width_scale: u32,
    pub frame_height_scale: u32,
    pub error_resilient: u32,
    pub kf_auto: u32,
    pub kf_min_dist: u32,
    pub kf_max_dist: u32,
    pub bits_per_second: u32,
    pub intra_period: u32,
    pub reference_frames: [VASurfaceID; 4usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSequenceParameterBufferVP8 = _VAEncSequenceParameterBufferVP8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferVP8 {
    pub reconstructed_frame: VASurfaceID,
    pub ref_last_frame: VASurfaceID,
    pub ref_gf_frame: VASurfaceID,
    pub ref_arf_frame: VASurfaceID,
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP8__bindgen_ty_2,
    pub loop_filter_level: [i8; 4usize],
    pub ref_lf_delta: [i8; 4usize],
    pub mode_lf_delta: [i8; 4usize],
    pub sharpness_level: u8,
    pub clamp_qindex_high: u8,
    pub clamp_qindex_low: u8,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_last(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_last(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_gf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_gf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_ref_arf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_ref_arf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn first_ref(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_first_ref(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn second_ref(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_second_ref(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_kf: u32,
        no_ref_last: u32,
        no_ref_gf: u32,
        no_ref_arf: u32,
        temporal_id: u32,
        first_ref: u32,
        second_ref: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_kf: u32 = unsafe { ::std::mem::transmute(force_kf) };
            force_kf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_ref_last: u32 = unsafe { ::std::mem::transmute(no_ref_last) };
            no_ref_last as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let no_ref_gf: u32 = unsafe { ::std::mem::transmute(no_ref_gf) };
            no_ref_gf as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let no_ref_arf: u32 = unsafe { ::std::mem::transmute(no_ref_arf) };
            no_ref_arf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 8u8, {
            let temporal_id: u32 = unsafe { ::std::mem::transmute(temporal_id) };
            temporal_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let first_ref: u32 = unsafe { ::std::mem::transmute(first_ref) };
            first_ref as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let second_ref: u32 = unsafe { ::std::mem::transmute(second_ref) };
            second_ref as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP8__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn color_space(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_color_space(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recon_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_recon_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_partitions(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_partitions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_token_partitions(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_num_token_partitions(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn clamping_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clamping_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_mb_segmentation_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_mb_segmentation_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn update_segment_feature_data(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_update_segment_feature_data(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loop_filter_adj_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_loop_filter_adj_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_entropy_probs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_entropy_probs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_golden_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_golden_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_alternate_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_alternate_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_last(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_last(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn copy_buffer_to_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_copy_buffer_to_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn copy_buffer_to_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_copy_buffer_to_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_golden(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_golden(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sign_bias_alternate(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign_bias_alternate(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_no_coeff_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_no_coeff_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn forced_lf_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_forced_lf_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        version: u32,
        show_frame: u32,
        color_space: u32,
        recon_filter_type: u32,
        loop_filter_type: u32,
        auto_partitions: u32,
        num_token_partitions: u32,
        clamping_type: u32,
        segmentation_enabled: u32,
        update_mb_segmentation_map: u32,
        update_segment_feature_data: u32,
        loop_filter_adj_enable: u32,
        refresh_entropy_probs: u32,
        refresh_golden_frame: u32,
        refresh_alternate_frame: u32,
        refresh_last: u32,
        copy_buffer_to_golden: u32,
        copy_buffer_to_alternate: u32,
        sign_bias_golden: u32,
        sign_bias_alternate: u32,
        mb_no_coeff_skip: u32,
        forced_lf_adjustment: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let color_space: u32 = unsafe { ::std::mem::transmute(color_space) };
            color_space as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let recon_filter_type: u32 = unsafe { ::std::mem::transmute(recon_filter_type) };
            recon_filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let loop_filter_type: u32 = unsafe { ::std::mem::transmute(loop_filter_type) };
            loop_filter_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let auto_partitions: u32 = unsafe { ::std::mem::transmute(auto_partitions) };
            auto_partitions as u64
        });
        __bindgen_bitfield_unit.set(11usize, 2u8, {
            let num_token_partitions: u32 = unsafe { ::std::mem::transmute(num_token_partitions) };
            num_token_partitions as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let clamping_type: u32 = unsafe { ::std::mem::transmute(clamping_type) };
            clamping_type as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let update_mb_segmentation_map: u32 =
                unsafe { ::std::mem::transmute(update_mb_segmentation_map) };
            update_mb_segmentation_map as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let update_segment_feature_data: u32 =
                unsafe { ::std::mem::transmute(update_segment_feature_data) };
            update_segment_feature_data as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let loop_filter_adj_enable: u32 =
                unsafe { ::std::mem::transmute(loop_filter_adj_enable) };
            loop_filter_adj_enable as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let refresh_entropy_probs: u32 =
                unsafe { ::std::mem::transmute(refresh_entropy_probs) };
            refresh_entropy_probs as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let refresh_golden_frame: u32 = unsafe { ::std::mem::transmute(refresh_golden_frame) };
            refresh_golden_frame as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let refresh_alternate_frame: u32 =
                unsafe { ::std::mem::transmute(refresh_alternate_frame) };
            refresh_alternate_frame as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let refresh_last: u32 = unsafe { ::std::mem::transmute(refresh_last) };
            refresh_last as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let copy_buffer_to_golden: u32 =
                unsafe { ::std::mem::transmute(copy_buffer_to_golden) };
            copy_buffer_to_golden as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let copy_buffer_to_alternate: u32 =
                unsafe { ::std::mem::transmute(copy_buffer_to_alternate) };
            copy_buffer_to_alternate as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sign_bias_golden: u32 = unsafe { ::std::mem::transmute(sign_bias_golden) };
            sign_bias_golden as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let sign_bias_alternate: u32 = unsafe { ::std::mem::transmute(sign_bias_alternate) };
            sign_bias_alternate as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let mb_no_coeff_skip: u32 = unsafe { ::std::mem::transmute(mb_no_coeff_skip) };
            mb_no_coeff_skip as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let forced_lf_adjustment: u32 = unsafe { ::std::mem::transmute(forced_lf_adjustment) };
            forced_lf_adjustment as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP8__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferVP8 = _VAEncPictureParameterBufferVP8;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMBMapBufferVP8 {
    pub num_mbs: u32,
    pub mb_segment_id: *mut u8,
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAEncMBMapBufferVP8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMBMapBufferVP8 = _VAEncMBMapBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAQMatrixBufferVP8 {
    pub quantization_index: [u16; 4usize],
    pub quantization_index_delta: [i16; 5usize],
    pub va_reserved: [u32; 4usize],
}
pub type VAQMatrixBufferVP8 = _VAQMatrixBufferVP8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VACodedBufferVP9Status {
    pub base_qp_index: u16,
    pub loop_filter_level: u8,
    pub long_term_indication: u8,
    pub next_frame_width: u16,
    pub next_frame_height: u16,
    pub va_reserved: [u32; 4usize],
}
pub type VACodedBufferVP9Status = _VACodedBufferVP9Status;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSequenceParameterBufferVP9 {
    pub max_frame_width: u32,
    pub max_frame_height: u32,
    pub kf_auto: u32,
    pub kf_min_dist: u32,
    pub kf_max_dist: u32,
    pub bits_per_second: u32,
    pub intra_period: u32,
    pub va_reserved: [u32; 4usize],
}
pub type VAEncSequenceParameterBufferVP9 = _VAEncSequenceParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncPictureParameterBufferVP9 {
    pub frame_width_src: u32,
    pub frame_height_src: u32,
    pub frame_width_dst: u32,
    pub frame_height_dst: u32,
    pub reconstructed_frame: VASurfaceID,
    pub reference_frames: [VASurfaceID; 8usize],
    pub coded_buf: VABufferID,
    pub ref_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_1,
    pub pic_flags: _VAEncPictureParameterBufferVP9__bindgen_ty_2,
    pub refresh_frame_flags: u8,
    pub luma_ac_qindex: u8,
    pub luma_dc_qindex_delta: i8,
    pub chroma_ac_qindex_delta: i8,
    pub chroma_dc_qindex_delta: i8,
    pub filter_level: u8,
    pub sharpness_level: u8,
    pub ref_lf_delta: [i8; 4usize],
    pub mode_lf_delta: [i8; 2usize],
    pub bit_offset_ref_lf_delta: u16,
    pub bit_offset_mode_lf_delta: u16,
    pub bit_offset_lf_level: u16,
    pub bit_offset_qindex: u16,
    pub bit_offset_first_partition_size: u16,
    pub bit_offset_segmentation: u16,
    pub bit_size_segmentation: u16,
    pub log2_tile_rows: u8,
    pub log2_tile_columns: u8,
    pub skip_frame_flag: u8,
    pub number_skip_frames: u8,
    pub skip_frames_size: u32,
    pub va_reserved: [u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    pub bits: _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn force_kf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_kf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_frame_ctrl_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_frame_ctrl_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_frame_ctrl_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_last_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_last_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_last_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_last_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_gf_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_gf_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_gf_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_gf_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_arf_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ref_arf_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_arf_sign_bias(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ref_arf_sign_bias(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temporal_id(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_temporal_id(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_kf: u32,
        ref_frame_ctrl_l0: u32,
        ref_frame_ctrl_l1: u32,
        ref_last_idx: u32,
        ref_last_sign_bias: u32,
        ref_gf_idx: u32,
        ref_gf_sign_bias: u32,
        ref_arf_idx: u32,
        ref_arf_sign_bias: u32,
        temporal_id: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_kf: u32 = unsafe { ::std::mem::transmute(force_kf) };
            force_kf as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let ref_frame_ctrl_l0: u32 = unsafe { ::std::mem::transmute(ref_frame_ctrl_l0) };
            ref_frame_ctrl_l0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let ref_frame_ctrl_l1: u32 = unsafe { ::std::mem::transmute(ref_frame_ctrl_l1) };
            ref_frame_ctrl_l1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let ref_last_idx: u32 = unsafe { ::std::mem::transmute(ref_last_idx) };
            ref_last_idx as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ref_last_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_last_sign_bias) };
            ref_last_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let ref_gf_idx: u32 = unsafe { ::std::mem::transmute(ref_gf_idx) };
            ref_gf_idx as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ref_gf_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_gf_sign_bias) };
            ref_gf_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(15usize, 3u8, {
            let ref_arf_idx: u32 = unsafe { ::std::mem::transmute(ref_arf_idx) };
            ref_arf_idx as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ref_arf_sign_bias: u32 = unsafe { ::std::mem::transmute(ref_arf_sign_bias) };
            ref_arf_sign_bias as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let temporal_id: u32 = unsafe { ::std::mem::transmute(temporal_id) };
            temporal_id as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    pub bits: _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1,
    pub value: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncPictureParameterBufferVP9__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn frame_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn show_frame(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_show_frame(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn error_resilient_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_error_resilient_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_high_precision_mv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_allow_high_precision_mv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mcomp_filter_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mcomp_filter_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_parallel_decoding_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frame_parallel_decoding_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reset_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn refresh_frame_context(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_refresh_frame_context(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frame_context_idx(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frame_context_idx(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_temporal_update(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_temporal_update(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segmentation_update_map(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_segmentation_update_map(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lossless_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lossless_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn comp_prediction_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_comp_prediction_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_segmentation(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_auto_segmentation(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn super_frame_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_super_frame_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_type: u32,
        show_frame: u32,
        error_resilient_mode: u32,
        intra_only: u32,
        allow_high_precision_mv: u32,
        mcomp_filter_type: u32,
        frame_parallel_decoding_mode: u32,
        reset_frame_context: u32,
        refresh_frame_context: u32,
        frame_context_idx: u32,
        segmentation_enabled: u32,
        segmentation_temporal_update: u32,
        segmentation_update_map: u32,
        lossless_mode: u32,
        comp_prediction_mode: u32,
        auto_segmentation: u32,
        super_frame_flag: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frame_type: u32 = unsafe { ::std::mem::transmute(frame_type) };
            frame_type as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let show_frame: u32 = unsafe { ::std::mem::transmute(show_frame) };
            show_frame as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let error_resilient_mode: u32 = unsafe { ::std::mem::transmute(error_resilient_mode) };
            error_resilient_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let intra_only: u32 = unsafe { ::std::mem::transmute(intra_only) };
            intra_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let allow_high_precision_mv: u32 =
                unsafe { ::std::mem::transmute(allow_high_precision_mv) };
            allow_high_precision_mv as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mcomp_filter_type: u32 = unsafe { ::std::mem::transmute(mcomp_filter_type) };
            mcomp_filter_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let frame_parallel_decoding_mode: u32 =
                unsafe { ::std::mem::transmute(frame_parallel_decoding_mode) };
            frame_parallel_decoding_mode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let reset_frame_context: u32 = unsafe { ::std::mem::transmute(reset_frame_context) };
            reset_frame_context as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let refresh_frame_context: u32 =
                unsafe { ::std::mem::transmute(refresh_frame_context) };
            refresh_frame_context as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let frame_context_idx: u32 = unsafe { ::std::mem::transmute(frame_context_idx) };
            frame_context_idx as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let segmentation_enabled: u32 = unsafe { ::std::mem::transmute(segmentation_enabled) };
            segmentation_enabled as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let segmentation_temporal_update: u32 =
                unsafe { ::std::mem::transmute(segmentation_temporal_update) };
            segmentation_temporal_update as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let segmentation_update_map: u32 =
                unsafe { ::std::mem::transmute(segmentation_update_map) };
            segmentation_update_map as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let lossless_mode: u32 = unsafe { ::std::mem::transmute(lossless_mode) };
            lossless_mode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let comp_prediction_mode: u32 = unsafe { ::std::mem::transmute(comp_prediction_mode) };
            comp_prediction_mode as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let auto_segmentation: u32 = unsafe { ::std::mem::transmute(auto_segmentation) };
            auto_segmentation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let super_frame_flag: u32 = unsafe { ::std::mem::transmute(super_frame_flag) };
            super_frame_flag as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncPictureParameterBufferVP9__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncPictureParameterBufferVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncPictureParameterBufferVP9 = _VAEncPictureParameterBufferVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncSegParamVP9 {
    pub seg_flags: _VAEncSegParamVP9__bindgen_ty_1,
    pub segment_lf_level_delta: i8,
    pub segment_qindex_delta: i16,
    pub va_reserved: [u32; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncSegParamVP9__bindgen_ty_1 {
    pub bits: _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncSegParamVP9__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn segment_reference_enabled(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn segment_reference_skipped(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_segment_reference_skipped(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        segment_reference_enabled: u8,
        segment_reference: u8,
        segment_reference_skipped: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let segment_reference_enabled: u8 =
                unsafe { ::std::mem::transmute(segment_reference_enabled) };
            segment_reference_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let segment_reference: u8 = unsafe { ::std::mem::transmute(segment_reference) };
            segment_reference as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let segment_reference_skipped: u8 =
                unsafe { ::std::mem::transmute(segment_reference_skipped) };
            segment_reference_skipped as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncSegParamVP9__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncSegParamVP9 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncSegParamVP9 = _VAEncSegParamVP9;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncMiscParameterTypeVP9PerSegmantParam {
    pub seg_data: [VAEncSegParamVP9; 8usize],
    pub va_reserved: [u32; 4usize],
}
impl Default for _VAEncMiscParameterTypeVP9PerSegmantParam {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAEncMiscParameterTypeVP9PerSegmantParam = _VAEncMiscParameterTypeVP9PerSegmantParam;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncMiscParameterFEIFrameControlH264 {
    pub function: u32,
    pub mb_ctrl: VABufferID,
    pub distortion: VABufferID,
    pub mv_data: VABufferID,
    pub mb_code_data: VABufferID,
    pub qp: VABufferID,
    pub mv_predictor: VABufferID,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub max_frame_size: u32,
    pub num_passes: u32,
    pub delta_qp: *mut u8,
    pub reserved3: [u32; 4usize],
}
impl Default for _VAEncMiscParameterFEIFrameControlH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAEncMiscParameterFEIFrameControlH264 {
    #[inline]
    pub fn num_mv_predictors_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn num_mv_predictors_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_mv_predictors_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn search_path(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len_sp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_len_sp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_pred_l1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_multi_pred_l1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_pel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(78usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sub_pel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(78usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(82usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(82usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn distortion_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_distortion_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repartition_check_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_repartition_check_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adaptive_search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mv_predictor_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mv_predictor_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_input(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_input(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_size_ctrl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_size_ctrl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn colocated_mb_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_colocated_mb_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(92usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(92usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_width(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_height(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_window(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_search_window(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(116usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(116usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        num_mv_predictors_l0: u32,
        num_mv_predictors_l1: u32,
        search_path: u32,
        len_sp: u32,
        reserved0: u32,
        sub_mb_part_mask: u32,
        intra_part_mask: u32,
        multi_pred_l0: u32,
        multi_pred_l1: u32,
        sub_pel_mode: u32,
        inter_sad: u32,
        intra_sad: u32,
        distortion_type: u32,
        repartition_check_enable: u32,
        adaptive_search: u32,
        mv_predictor_enable: u32,
        mb_qp: u32,
        mb_input: u32,
        mb_size_ctrl: u32,
        colocated_mb_distortion: u32,
        reserved1: u32,
        ref_width: u32,
        ref_height: u32,
        search_window: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let num_mv_predictors_l0: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l0) };
            num_mv_predictors_l0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let num_mv_predictors_l1: u32 = unsafe { ::std::mem::transmute(num_mv_predictors_l1) };
            num_mv_predictors_l1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let search_path: u32 = unsafe { ::std::mem::transmute(search_path) };
            search_path as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let len_sp: u32 = unsafe { ::std::mem::transmute(len_sp) };
            len_sp as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 7u8, {
            let sub_mb_part_mask: u32 = unsafe { ::std::mem::transmute(sub_mb_part_mask) };
            sub_mb_part_mask as u64
        });
        __bindgen_bitfield_unit.set(71usize, 5u8, {
            let intra_part_mask: u32 = unsafe { ::std::mem::transmute(intra_part_mask) };
            intra_part_mask as u64
        });
        __bindgen_bitfield_unit.set(76usize, 1u8, {
            let multi_pred_l0: u32 = unsafe { ::std::mem::transmute(multi_pred_l0) };
            multi_pred_l0 as u64
        });
        __bindgen_bitfield_unit.set(77usize, 1u8, {
            let multi_pred_l1: u32 = unsafe { ::std::mem::transmute(multi_pred_l1) };
            multi_pred_l1 as u64
        });
        __bindgen_bitfield_unit.set(78usize, 2u8, {
            let sub_pel_mode: u32 = unsafe { ::std::mem::transmute(sub_pel_mode) };
            sub_pel_mode as u64
        });
        __bindgen_bitfield_unit.set(80usize, 2u8, {
            let inter_sad: u32 = unsafe { ::std::mem::transmute(inter_sad) };
            inter_sad as u64
        });
        __bindgen_bitfield_unit.set(82usize, 2u8, {
            let intra_sad: u32 = unsafe { ::std::mem::transmute(intra_sad) };
            intra_sad as u64
        });
        __bindgen_bitfield_unit.set(84usize, 1u8, {
            let distortion_type: u32 = unsafe { ::std::mem::transmute(distortion_type) };
            distortion_type as u64
        });
        __bindgen_bitfield_unit.set(85usize, 1u8, {
            let repartition_check_enable: u32 =
                unsafe { ::std::mem::transmute(repartition_check_enable) };
            repartition_check_enable as u64
        });
        __bindgen_bitfield_unit.set(86usize, 1u8, {
            let adaptive_search: u32 = unsafe { ::std::mem::transmute(adaptive_search) };
            adaptive_search as u64
        });
        __bindgen_bitfield_unit.set(87usize, 1u8, {
            let mv_predictor_enable: u32 = unsafe { ::std::mem::transmute(mv_predictor_enable) };
            mv_predictor_enable as u64
        });
        __bindgen_bitfield_unit.set(88usize, 1u8, {
            let mb_qp: u32 = unsafe { ::std::mem::transmute(mb_qp) };
            mb_qp as u64
        });
        __bindgen_bitfield_unit.set(89usize, 1u8, {
            let mb_input: u32 = unsafe { ::std::mem::transmute(mb_input) };
            mb_input as u64
        });
        __bindgen_bitfield_unit.set(90usize, 1u8, {
            let mb_size_ctrl: u32 = unsafe { ::std::mem::transmute(mb_size_ctrl) };
            mb_size_ctrl as u64
        });
        __bindgen_bitfield_unit.set(91usize, 1u8, {
            let colocated_mb_distortion: u32 =
                unsafe { ::std::mem::transmute(colocated_mb_distortion) };
            colocated_mb_distortion as u64
        });
        __bindgen_bitfield_unit.set(92usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let ref_width: u32 = unsafe { ::std::mem::transmute(ref_width) };
            ref_width as u64
        });
        __bindgen_bitfield_unit.set(104usize, 8u8, {
            let ref_height: u32 = unsafe { ::std::mem::transmute(ref_height) };
            ref_height as u64
        });
        __bindgen_bitfield_unit.set(112usize, 4u8, {
            let search_window: u32 = unsafe { ::std::mem::transmute(search_window) };
            search_window as u64
        });
        __bindgen_bitfield_unit.set(116usize, 12u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncMiscParameterFEIFrameControlH264 = _VAEncMiscParameterFEIFrameControlH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBControlH264 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved1: u32,
    pub reserved2: u32,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl _VAEncFEIMBControlH264 {
    #[inline]
    pub fn force_to_intra(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_intra(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_skip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_skip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_to_nonskip(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_force_to_nonskip(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_direct_bias_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_direct_bias_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_motion_bias_adjustment(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_motion_bias_adjustment(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_mv_cost_scaling_factor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ext_mv_cost_scaling_factor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_to_intra: u32,
        force_to_skip: u32,
        force_to_nonskip: u32,
        enable_direct_bias_adjustment: u32,
        enable_motion_bias_adjustment: u32,
        ext_mv_cost_scaling_factor: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_to_intra: u32 = unsafe { ::std::mem::transmute(force_to_intra) };
            force_to_intra as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_to_skip: u32 = unsafe { ::std::mem::transmute(force_to_skip) };
            force_to_skip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let force_to_nonskip: u32 = unsafe { ::std::mem::transmute(force_to_nonskip) };
            force_to_nonskip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let enable_direct_bias_adjustment: u32 =
                unsafe { ::std::mem::transmute(enable_direct_bias_adjustment) };
            enable_direct_bias_adjustment as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let enable_motion_bias_adjustment: u32 =
                unsafe { ::std::mem::transmute(enable_motion_bias_adjustment) };
            enable_motion_bias_adjustment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ext_mv_cost_scaling_factor: u32 =
                unsafe { ::std::mem::transmute(ext_mv_cost_scaling_factor) };
            ext_mv_cost_scaling_factor as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn target_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_target_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reserved3: u32,
        target_size_in_word: u32,
        max_size_in_word: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let target_size_in_word: u32 = unsafe { ::std::mem::transmute(target_size_in_word) };
            target_size_in_word as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let max_size_in_word: u32 = unsafe { ::std::mem::transmute(max_size_in_word) };
            max_size_in_word as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMBControlH264 = _VAEncFEIMBControlH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorH264 {
    pub ref_idx: [_VAEncFEIMVPredictorH264__bindgen_ty_1; 4usize],
    pub reserved: u32,
    pub mv: [VAMotionVector; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMVPredictorH264__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl _VAEncFEIMVPredictorH264__bindgen_ty_1 {
    #[inline]
    pub fn ref_idx_l0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ref_idx_l1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ref_idx_l0: u8, ref_idx_l1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ref_idx_l0: u8 = unsafe { ::std::mem::transmute(ref_idx_l0) };
            ref_idx_l0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ref_idx_l1: u8 = unsafe { ::std::mem::transmute(ref_idx_l1) };
            ref_idx_l1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMVPredictorH264 = _VAEncFEIMVPredictorH264;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VAEncFEIMBCodeH264 {
    pub reserved0: [u32; 3usize],
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub mb_mode: _VAEncFEIMBCodeH264__bindgen_ty_1,
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved9: [u32; 4usize],
    pub reserved10: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VAEncFEIMBCodeH264__bindgen_ty_1 {
    pub intra_mb: _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1,
    pub inter_mb: _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn luma_intra_pred_modes0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn luma_intra_pred_modes3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_luma_intra_pred_modes3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn chroma_intra_pred_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_chroma_intra_pred_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_pred_avail_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(66usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_pred_avail_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(66usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_pred_avail_flagF(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_pred_avail_flagF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        luma_intra_pred_modes0: u32,
        luma_intra_pred_modes1: u32,
        luma_intra_pred_modes2: u32,
        luma_intra_pred_modes3: u32,
        chroma_intra_pred_mode: u32,
        intra_pred_avail_flag: u32,
        intra_pred_avail_flagF: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let luma_intra_pred_modes0: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes0) };
            luma_intra_pred_modes0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let luma_intra_pred_modes1: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes1) };
            luma_intra_pred_modes1 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let luma_intra_pred_modes2: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes2) };
            luma_intra_pred_modes2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let luma_intra_pred_modes3: u32 =
                unsafe { ::std::mem::transmute(luma_intra_pred_modes3) };
            luma_intra_pred_modes3 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 2u8, {
            let chroma_intra_pred_mode: u32 =
                unsafe { ::std::mem::transmute(chroma_intra_pred_mode) };
            chroma_intra_pred_mode as u64
        });
        __bindgen_bitfield_unit.set(66usize, 5u8, {
            let intra_pred_avail_flag: u32 =
                unsafe { ::std::mem::transmute(intra_pred_avail_flag) };
            intra_pred_avail_flag as u64
        });
        __bindgen_bitfield_unit.set(71usize, 1u8, {
            let intra_pred_avail_flagF: u32 =
                unsafe { ::std::mem::transmute(intra_pred_avail_flagF) };
            intra_pred_avail_flagF as u64
        });
        __bindgen_bitfield_unit.set(72usize, 24u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 12usize]>,
}
impl _VAEncFEIMBCodeH264__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn sub_mb_shapes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_shapes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_pred_modes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_pred_modes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l0_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l0_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_idx_l1_3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(88usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_idx_l1_3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(88usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sub_mb_shapes: u32,
        sub_mb_pred_modes: u32,
        reserved7: u32,
        ref_idx_l0_0: u32,
        ref_idx_l0_1: u32,
        ref_idx_l0_2: u32,
        ref_idx_l0_3: u32,
        ref_idx_l1_0: u32,
        ref_idx_l1_1: u32,
        ref_idx_l1_2: u32,
        ref_idx_l1_3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 12usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 12usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let sub_mb_shapes: u32 = unsafe { ::std::mem::transmute(sub_mb_shapes) };
            sub_mb_shapes as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let sub_mb_pred_modes: u32 = unsafe { ::std::mem::transmute(sub_mb_pred_modes) };
            sub_mb_pred_modes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved7: u32 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let ref_idx_l0_0: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_0) };
            ref_idx_l0_0 as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let ref_idx_l0_1: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_1) };
            ref_idx_l0_1 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let ref_idx_l0_2: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_2) };
            ref_idx_l0_2 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let ref_idx_l0_3: u32 = unsafe { ::std::mem::transmute(ref_idx_l0_3) };
            ref_idx_l0_3 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ref_idx_l1_0: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_0) };
            ref_idx_l1_0 as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ref_idx_l1_1: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_1) };
            ref_idx_l1_1 as u64
        });
        __bindgen_bitfield_unit.set(80usize, 8u8, {
            let ref_idx_l1_2: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_2) };
            ref_idx_l1_2 as u64
        });
        __bindgen_bitfield_unit.set(88usize, 8u8, {
            let ref_idx_l1_3: u32 = unsafe { ::std::mem::transmute(ref_idx_l1_3) };
            ref_idx_l1_3 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for _VAEncFEIMBCodeH264__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VAEncFEIMBCodeH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAEncFEIMBCodeH264 {
    #[inline]
    pub fn inter_mb_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_skip_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_skip_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mb_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mb_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_mb_polarity_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_mb_polarity_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_mb_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn field_mb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_field_mb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform8x8_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform8x8_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_cr_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_cr_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_cb_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_cb_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dc_block_coded_y_flag(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dc_block_coded_y_flag(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn horz_origin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_horz_origin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn vert_origin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vert_origin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_cb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_cb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cbp_cr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cbp_cr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn qp_prime_y(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_qp_prime_y(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(104usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(104usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_skip_conv_disable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(121usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_skip_conv_disable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(121usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_last_mb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(122usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_last_mb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(122usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_coefficient_clamp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(123usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_coefficient_clamp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(123usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct8x8_pattern(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(124usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_direct8x8_pattern(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(124usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inter_mb_mode: u32,
        mb_skip_flag: u32,
        reserved1: u32,
        intra_mb_mode: u32,
        reserved2: u32,
        field_mb_polarity_flag: u32,
        mb_type: u32,
        intra_mb_flag: u32,
        field_mb_flag: u32,
        transform8x8_flag: u32,
        reserved3: u32,
        dc_block_coded_cr_flag: u32,
        dc_block_coded_cb_flag: u32,
        dc_block_coded_y_flag: u32,
        reserved4: u32,
        horz_origin: u32,
        vert_origin: u32,
        cbp_y: u32,
        cbp_cb: u32,
        cbp_cr: u32,
        qp_prime_y: u32,
        reserved5: u32,
        mb_skip_conv_disable: u32,
        is_last_mb: u32,
        enable_coefficient_clamp: u32,
        direct8x8_pattern: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let inter_mb_mode: u32 = unsafe { ::std::mem::transmute(inter_mb_mode) };
            inter_mb_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mb_skip_flag: u32 = unsafe { ::std::mem::transmute(mb_skip_flag) };
            mb_skip_flag as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let intra_mb_mode: u32 = unsafe { ::std::mem::transmute(intra_mb_mode) };
            intra_mb_mode as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let field_mb_polarity_flag: u32 =
                unsafe { ::std::mem::transmute(field_mb_polarity_flag) };
            field_mb_polarity_flag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let mb_type: u32 = unsafe { ::std::mem::transmute(mb_type) };
            mb_type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let intra_mb_flag: u32 = unsafe { ::std::mem::transmute(intra_mb_flag) };
            intra_mb_flag as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let field_mb_flag: u32 = unsafe { ::std::mem::transmute(field_mb_flag) };
            field_mb_flag as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let transform8x8_flag: u32 = unsafe { ::std::mem::transmute(transform8x8_flag) };
            transform8x8_flag as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let dc_block_coded_cr_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_cr_flag) };
            dc_block_coded_cr_flag as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let dc_block_coded_cb_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_cb_flag) };
            dc_block_coded_cb_flag as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let dc_block_coded_y_flag: u32 =
                unsafe { ::std::mem::transmute(dc_block_coded_y_flag) };
            dc_block_coded_y_flag as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let reserved4: u32 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let horz_origin: u32 = unsafe { ::std::mem::transmute(horz_origin) };
            horz_origin as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vert_origin: u32 = unsafe { ::std::mem::transmute(vert_origin) };
            vert_origin as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let cbp_y: u32 = unsafe { ::std::mem::transmute(cbp_y) };
            cbp_y as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let cbp_cb: u32 = unsafe { ::std::mem::transmute(cbp_cb) };
            cbp_cb as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let cbp_cr: u32 = unsafe { ::std::mem::transmute(cbp_cr) };
            cbp_cr as u64
        });
        __bindgen_bitfield_unit.set(96usize, 8u8, {
            let qp_prime_y: u32 = unsafe { ::std::mem::transmute(qp_prime_y) };
            qp_prime_y as u64
        });
        __bindgen_bitfield_unit.set(104usize, 17u8, {
            let reserved5: u32 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(121usize, 1u8, {
            let mb_skip_conv_disable: u32 = unsafe { ::std::mem::transmute(mb_skip_conv_disable) };
            mb_skip_conv_disable as u64
        });
        __bindgen_bitfield_unit.set(122usize, 1u8, {
            let is_last_mb: u32 = unsafe { ::std::mem::transmute(is_last_mb) };
            is_last_mb as u64
        });
        __bindgen_bitfield_unit.set(123usize, 1u8, {
            let enable_coefficient_clamp: u32 =
                unsafe { ::std::mem::transmute(enable_coefficient_clamp) };
            enable_coefficient_clamp as u64
        });
        __bindgen_bitfield_unit.set(124usize, 4u8, {
            let direct8x8_pattern: u32 = unsafe { ::std::mem::transmute(direct8x8_pattern) };
            direct8x8_pattern as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn reserved8(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn target_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_target_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn max_size_in_word(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_size_in_word(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        reserved8: u32,
        target_size_in_word: u32,
        max_size_in_word: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved8: u32 = unsafe { ::std::mem::transmute(reserved8) };
            reserved8 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let target_size_in_word: u32 = unsafe { ::std::mem::transmute(target_size_in_word) };
            target_size_in_word as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let max_size_in_word: u32 = unsafe { ::std::mem::transmute(max_size_in_word) };
            max_size_in_word as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIMBCodeH264 = _VAEncFEIMBCodeH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAEncFEIDistortionH264 {
    pub inter_distortion: [u16; 16usize],
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub reserved1: [u32; 2usize],
}
impl _VAEncFEIDistortionH264 {
    #[inline]
    pub fn best_inter_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_intra_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_intra_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn colocated_mb_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_colocated_mb_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        best_inter_distortion: u32,
        best_intra_distortion: u32,
        colocated_mb_distortion: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let best_inter_distortion: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion) };
            best_inter_distortion as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let best_intra_distortion: u32 =
                unsafe { ::std::mem::transmute(best_intra_distortion) };
            best_intra_distortion as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let colocated_mb_distortion: u32 =
                unsafe { ::std::mem::transmute(colocated_mb_distortion) };
            colocated_mb_distortion as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAEncFEIDistortionH264 = _VAEncFEIDistortionH264;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsParameterH264 {
    pub stats_params: VAStatsStatisticsParameter,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub reserved4: [u32; 2usize],
}
impl Default for _VAStatsStatisticsParameterH264 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _VAStatsStatisticsParameterH264 {
    #[inline]
    pub fn frame_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_frame_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn len_sp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_len_sp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_path(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_search_path(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_mb_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_sub_mb_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn sub_pel_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_sub_pel_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_inter_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_sad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_intra_sad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adaptive_search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_adaptive_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mv_predictor_ctrl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mv_predictor_ctrl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mb_qp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_qp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ft_enable(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ft_enable(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_part_mask(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_intra_part_mask(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_width(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_width(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ref_height(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(72usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ref_height(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(72usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn search_window(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_search_window(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(84usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(84usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_mv_output(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_mv_output(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_statistics_output(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_statistics_output(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_8x8_statistics(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enable_8x8_statistics(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(99usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(99usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frame_qp: u32,
        len_sp: u32,
        search_path: u32,
        reserved0: u32,
        sub_mb_part_mask: u32,
        sub_pel_mode: u32,
        inter_sad: u32,
        intra_sad: u32,
        adaptive_search: u32,
        mv_predictor_ctrl: u32,
        mb_qp: u32,
        ft_enable: u32,
        intra_part_mask: u32,
        reserved1: u32,
        ref_width: u32,
        ref_height: u32,
        search_window: u32,
        reserved2: u32,
        disable_mv_output: u32,
        disable_statistics_output: u32,
        enable_8x8_statistics: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let frame_qp: u32 = unsafe { ::std::mem::transmute(frame_qp) };
            frame_qp as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let len_sp: u32 = unsafe { ::std::mem::transmute(len_sp) };
            len_sp as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let search_path: u32 = unsafe { ::std::mem::transmute(search_path) };
            search_path as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 7u8, {
            let sub_mb_part_mask: u32 = unsafe { ::std::mem::transmute(sub_mb_part_mask) };
            sub_mb_part_mask as u64
        });
        __bindgen_bitfield_unit.set(39usize, 2u8, {
            let sub_pel_mode: u32 = unsafe { ::std::mem::transmute(sub_pel_mode) };
            sub_pel_mode as u64
        });
        __bindgen_bitfield_unit.set(41usize, 2u8, {
            let inter_sad: u32 = unsafe { ::std::mem::transmute(inter_sad) };
            inter_sad as u64
        });
        __bindgen_bitfield_unit.set(43usize, 2u8, {
            let intra_sad: u32 = unsafe { ::std::mem::transmute(intra_sad) };
            intra_sad as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let adaptive_search: u32 = unsafe { ::std::mem::transmute(adaptive_search) };
            adaptive_search as u64
        });
        __bindgen_bitfield_unit.set(46usize, 3u8, {
            let mv_predictor_ctrl: u32 = unsafe { ::std::mem::transmute(mv_predictor_ctrl) };
            mv_predictor_ctrl as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let mb_qp: u32 = unsafe { ::std::mem::transmute(mb_qp) };
            mb_qp as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let ft_enable: u32 = unsafe { ::std::mem::transmute(ft_enable) };
            ft_enable as u64
        });
        __bindgen_bitfield_unit.set(51usize, 5u8, {
            let intra_part_mask: u32 = unsafe { ::std::mem::transmute(intra_part_mask) };
            intra_part_mask as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 8u8, {
            let ref_width: u32 = unsafe { ::std::mem::transmute(ref_width) };
            ref_width as u64
        });
        __bindgen_bitfield_unit.set(72usize, 8u8, {
            let ref_height: u32 = unsafe { ::std::mem::transmute(ref_height) };
            ref_height as u64
        });
        __bindgen_bitfield_unit.set(80usize, 4u8, {
            let search_window: u32 = unsafe { ::std::mem::transmute(search_window) };
            search_window as u64
        });
        __bindgen_bitfield_unit.set(84usize, 12u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(96usize, 1u8, {
            let disable_mv_output: u32 = unsafe { ::std::mem::transmute(disable_mv_output) };
            disable_mv_output as u64
        });
        __bindgen_bitfield_unit.set(97usize, 1u8, {
            let disable_statistics_output: u32 =
                unsafe { ::std::mem::transmute(disable_statistics_output) };
            disable_statistics_output as u64
        });
        __bindgen_bitfield_unit.set(98usize, 1u8, {
            let enable_8x8_statistics: u32 =
                unsafe { ::std::mem::transmute(enable_8x8_statistics) };
            enable_8x8_statistics as u64
        });
        __bindgen_bitfield_unit.set(99usize, 29u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAStatsStatisticsParameterH264 = _VAStatsStatisticsParameterH264;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _VAStatsStatisticsH264 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize]>,
    pub sum_coef: u32,
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub variance_16x16: u32,
    pub variance_8x8: [u32; 4usize],
    pub pixel_average_16x16: u32,
    pub pixel_average_8x8: [u32; 4usize],
}
impl _VAStatsStatisticsH264 {
    #[inline]
    pub fn best_inter_distortion0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_mode0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mode0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_inter_distortion1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_inter_distortion1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn inter_mode1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_inter_mode1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn best_intra_distortion(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_best_intra_distortion(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn intra_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(80usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_intra_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(80usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn num_non_zero_coef(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(96usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_num_non_zero_coef(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(96usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(112usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(112usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        best_inter_distortion0: u32,
        inter_mode0: u32,
        best_inter_distortion1: u32,
        inter_mode1: u32,
        best_intra_distortion: u32,
        intra_mode: u32,
        num_non_zero_coef: u32,
        reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 16usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let best_inter_distortion0: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion0) };
            best_inter_distortion0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let inter_mode0: u32 = unsafe { ::std::mem::transmute(inter_mode0) };
            inter_mode0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 16u8, {
            let best_inter_distortion1: u32 =
                unsafe { ::std::mem::transmute(best_inter_distortion1) };
            best_inter_distortion1 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 16u8, {
            let inter_mode1: u32 = unsafe { ::std::mem::transmute(inter_mode1) };
            inter_mode1 as u64
        });
        __bindgen_bitfield_unit.set(64usize, 16u8, {
            let best_intra_distortion: u32 =
                unsafe { ::std::mem::transmute(best_intra_distortion) };
            best_intra_distortion as u64
        });
        __bindgen_bitfield_unit.set(80usize, 16u8, {
            let intra_mode: u32 = unsafe { ::std::mem::transmute(intra_mode) };
            intra_mode as u64
        });
        __bindgen_bitfield_unit.set(96usize, 16u8, {
            let num_non_zero_coef: u32 = unsafe { ::std::mem::transmute(num_non_zero_coef) };
            num_non_zero_coef as u64
        });
        __bindgen_bitfield_unit.set(112usize, 16u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn mb_is_flat(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mb_is_flat(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(mb_is_flat: u32, reserved1: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mb_is_flat: u32 = unsafe { ::std::mem::transmute(mb_is_flat) };
            mb_is_flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type VAStatsStatisticsH264 = _VAStatsStatisticsH264;
pub const _VAProcFilterType_VAProcFilterNone: _VAProcFilterType = 0;
pub const _VAProcFilterType_VAProcFilterNoiseReduction: _VAProcFilterType = 1;
pub const _VAProcFilterType_VAProcFilterDeinterlacing: _VAProcFilterType = 2;
pub const _VAProcFilterType_VAProcFilterSharpening: _VAProcFilterType = 3;
pub const _VAProcFilterType_VAProcFilterColorBalance: _VAProcFilterType = 4;
pub const _VAProcFilterType_VAProcFilterSkinToneEnhancement: _VAProcFilterType = 5;
pub const _VAProcFilterType_VAProcFilterTotalColorCorrection: _VAProcFilterType = 6;
pub const _VAProcFilterType_VAProcFilterHVSNoiseReduction: _VAProcFilterType = 7;
pub const _VAProcFilterType_VAProcFilterHighDynamicRangeToneMapping: _VAProcFilterType = 8;
pub const _VAProcFilterType_VAProcFilter3DLUT: _VAProcFilterType = 9;
pub const _VAProcFilterType_VAProcFilterCount: _VAProcFilterType = 10;
pub type _VAProcFilterType = ::std::os::raw::c_uint;
pub use self::_VAProcFilterType as VAProcFilterType;
pub const _VAProcColorStandardType_VAProcColorStandardNone: _VAProcColorStandardType = 0;
pub const _VAProcColorStandardType_VAProcColorStandardBT601: _VAProcColorStandardType = 1;
pub const _VAProcColorStandardType_VAProcColorStandardBT709: _VAProcColorStandardType = 2;
pub const _VAProcColorStandardType_VAProcColorStandardBT470M: _VAProcColorStandardType = 3;
pub const _VAProcColorStandardType_VAProcColorStandardBT470BG: _VAProcColorStandardType = 4;
pub const _VAProcColorStandardType_VAProcColorStandardSMPTE170M: _VAProcColorStandardType = 5;
pub const _VAProcColorStandardType_VAProcColorStandardSMPTE240M: _VAProcColorStandardType = 6;
pub const _VAProcColorStandardType_VAProcColorStandardGenericFilm: _VAProcColorStandardType = 7;
pub const _VAProcColorStandardType_VAProcColorStandardSRGB: _VAProcColorStandardType = 8;
pub const _VAProcColorStandardType_VAProcColorStandardSTRGB: _VAProcColorStandardType = 9;
pub const _VAProcColorStandardType_VAProcColorStandardXVYCC601: _VAProcColorStandardType = 10;
pub const _VAProcColorStandardType_VAProcColorStandardXVYCC709: _VAProcColorStandardType = 11;
pub const _VAProcColorStandardType_VAProcColorStandardBT2020: _VAProcColorStandardType = 12;
pub const _VAProcColorStandardType_VAProcColorStandardExplicit: _VAProcColorStandardType = 13;
pub const _VAProcColorStandardType_VAProcColorStandardCount: _VAProcColorStandardType = 14;
pub type _VAProcColorStandardType = ::std::os::raw::c_uint;
pub use self::_VAProcColorStandardType as VAProcColorStandardType;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _VAProcPipelineCaps {
    pub pipeline_flags: u32,
    pub filter_flags: u32,
    pub num_forward_references: u32,
    pub num_backward_references: u32,
    pub input_color_standards: *mut VAProcColorStandardType,
    pub num_input_color_standards: u32,
    pub output_color_standards: *mut VAProcColorStandardType,
    pub num_output_color_standards: u32,
    pub rotation_flags: u32,
    pub blend_flags: u32,
    pub mirror_flags: u32,
    pub num_additional_outputs: u32,
    pub num_input_pixel_formats: u32,
    pub input_pixel_format: *mut u32,
    pub num_output_pixel_formats: u32,
    pub output_pixel_format: *mut u32,
    pub max_input_width: u32,
    pub max_input_height: u32,
    pub min_input_width: u32,
    pub min_input_height: u32,
    pub max_output_width: u32,
    pub max_output_height: u32,
    pub min_output_width: u32,
    pub min_output_height: u32,
    pub va_reserved: [u32; 14usize],
}
impl Default for _VAProcPipelineCaps {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type VAProcPipelineCaps = _VAProcPipelineCaps;
extern "C" {
    pub fn vaQueryVideoProcFilters(
        dpy: VADisplay,
        context: VAContextID,
        filters: *mut VAProcFilterType,
        num_filters: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcFilterCaps(
        dpy: VADisplay,
        context: VAContextID,
        type_: VAProcFilterType,
        filter_caps: *mut ::std::os::raw::c_void,
        num_filter_caps: *mut ::std::os::raw::c_uint,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaQueryVideoProcPipelineCaps(
        dpy: VADisplay,
        context: VAContextID,
        filters: *mut VABufferID,
        num_filters: ::std::os::raw::c_uint,
        pipeline_caps: *mut VAProcPipelineCaps,
    ) -> VAStatus;
}
pub type VAProtectedSessionID = VAGenericID;
extern "C" {
    pub fn vaCreateProtectedSession(
        dpy: VADisplay,
        config_id: VAConfigID,
        protected_session: *mut VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDestroyProtectedSession(
        dpy: VADisplay,
        protected_session: VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaAttachProtectedSession(
        dpy: VADisplay,
        id: VAGenericID,
        protected_session: VAProtectedSessionID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaDetachProtectedSession(dpy: VADisplay, id: VAGenericID) -> VAStatus;
}
extern "C" {
    pub fn vaProtectedSessionExecute(
        dpy: VADisplay,
        protected_session: VAProtectedSessionID,
        buf_id: VABufferID,
    ) -> VAStatus;
}
extern "C" {
    pub fn vaGetDisplayDRM(fd: ::std::os::raw::c_int) -> VADisplay;
}
