/* automatically generated by tools/bindgen-all-the-things */

#![allow(clippy::missing_safety_doc)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::upper_case_acronyms)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

pub use crate::bindings::*;

pub const vea_impl_type_VEA_FAKE: vea_impl_type = 0;
pub const vea_impl_type_GAVEA: vea_impl_type = 1;
pub type vea_impl_type = ::std::os::raw::c_uint;
pub use self::vea_impl_type as vea_impl_type_t;
#[repr(C)]
pub struct vea_profile {
    pub profile: video_codec_profile_t,
    pub max_width: u32,
    pub max_height: u32,
    pub max_framerate_numerator: u32,
    pub max_framerate_denominator: u32,
}
impl Default for vea_profile {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_profile_t = vea_profile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vea_capabilities {
    pub num_input_formats: usize,
    pub input_formats: *const video_pixel_format_t,
    pub num_output_formats: usize,
    pub output_formats: *const vea_profile_t,
}
impl Default for vea_capabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_capabilities_t = vea_capabilities;
pub const vea_bitrate_mode_VBR: vea_bitrate_mode = 0;
pub const vea_bitrate_mode_CBR: vea_bitrate_mode = 1;
pub type vea_bitrate_mode = ::std::os::raw::c_uint;
pub use self::vea_bitrate_mode as vea_bitrate_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vea_bitrate {
    pub mode: vea_bitrate_mode_t,
    pub target: u32,
    pub peak: u32,
}
impl Default for vea_bitrate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_bitrate_t = vea_bitrate;
#[repr(C)]
pub struct vea_config {
    pub input_format: video_pixel_format_t,
    pub input_visible_width: u32,
    pub input_visible_height: u32,
    pub output_profile: video_codec_profile_t,
    pub bitrate: vea_bitrate_t,
    pub initial_framerate: u32,
    pub has_initial_framerate: u8,
    pub h264_output_level: u8,
    pub has_h264_output_level: u8,
}
impl Default for vea_config {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_config_t = vea_config;
pub const vea_error_ILLEGAL_STATE_ERROR: vea_error = 0;
pub const vea_error_INVALID_ARGUMENT_ERROR: vea_error = 1;
pub const vea_error_PLATFORM_FAILURE_ERROR: vea_error = 2;
pub type vea_error = ::std::os::raw::c_uint;
pub use self::vea_error as vea_error_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vea_session_info {
    pub ctx: *mut ::std::os::raw::c_void,
    pub event_pipe_fd: ::std::os::raw::c_int,
}
impl Default for vea_session_info {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_session_info_t = vea_session_info;
pub type vea_input_buffer_id_t = i32;
pub type vea_output_buffer_id_t = i32;
pub const vea_event_type_REQUIRE_INPUT_BUFFERS: vea_event_type = 0;
pub const vea_event_type_PROCESSED_INPUT_BUFFER: vea_event_type = 1;
pub const vea_event_type_PROCESSED_OUTPUT_BUFFER: vea_event_type = 2;
pub const vea_event_type_VEA_FLUSH_RESPONSE: vea_event_type = 3;
pub const vea_event_type_VEA_NOTIFY_ERROR: vea_event_type = 4;
pub type vea_event_type = ::std::os::raw::c_uint;
pub use self::vea_event_type as vea_event_type_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vea_require_input_buffers_event_data {
    pub input_count: u32,
    pub input_frame_width: u32,
    pub input_frame_height: u32,
    pub output_buffer_size: u32,
}
pub type vea_require_input_buffers_event_data_t = vea_require_input_buffers_event_data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct vea_processed_output_buffer_event_data {
    pub output_buffer_id: vea_output_buffer_id_t,
    pub payload_size: u32,
    pub key_frame: u8,
    pub timestamp: i64,
}
pub type vea_processed_output_buffer_event_data_t = vea_processed_output_buffer_event_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub union vea_event_data {
    pub require_input_buffers: vea_require_input_buffers_event_data_t,
    pub processed_input_buffer_id: vea_input_buffer_id_t,
    pub processed_output_buffer: vea_processed_output_buffer_event_data_t,
    pub flush_done: u8,
    pub error: vea_error_t,
}
impl Default for vea_event_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_event_data_t = vea_event_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vea_event {
    pub event_type: vea_event_type_t,
    pub event_data: vea_event_data_t,
}
impl Default for vea_event {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type vea_event_t = vea_event;
extern "C" {
    pub fn initialize_encode(type_: vea_impl_type_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn deinitialize_encode(impl_: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn get_vea_capabilities(impl_: *mut ::std::os::raw::c_void) -> *const vea_capabilities_t;
}
extern "C" {
    pub fn init_encode_session(
        impl_: *mut ::std::os::raw::c_void,
        config: *mut vea_config_t,
    ) -> *mut vea_session_info_t;
}
extern "C" {
    pub fn close_encode_session(
        impl_: *mut ::std::os::raw::c_void,
        session_info: *mut vea_session_info_t,
    );
}
extern "C" {
    pub fn vea_encode(
        ctx: *mut ::std::os::raw::c_void,
        input_buffer_id: vea_input_buffer_id_t,
        fd: ::std::os::raw::c_int,
        num_planes: usize,
        planes: *mut video_frame_plane_t,
        timestamp: i64,
        force_keyframe: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vea_use_output_buffer(
        ctx: *mut ::std::os::raw::c_void,
        output_buffer_id: vea_output_buffer_id_t,
        fd: ::std::os::raw::c_int,
        offset: u32,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vea_request_encoding_params_change(
        ctx: *mut ::std::os::raw::c_void,
        bitrate: vea_bitrate_t,
        framerate: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vea_flush(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
