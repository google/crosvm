// Copyright 2019 The ChromiumOS Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* automatically generated by rust-bindgen */

/// @page page_xdg_shell_unstable_v6 The xdg_shell_unstable_v6 protocol
/// @section page_ifaces_xdg_shell_unstable_v6 Interfaces
/// - @subpage page_iface_zxdg_shell_v6 - create desktop-style surfaces
/// - @subpage page_iface_zxdg_positioner_v6 - child surface positioner
/// - @subpage page_iface_zxdg_surface_v6 - desktop user interface surface base interface
/// - @subpage page_iface_zxdg_toplevel_v6 - toplevel surface
/// - @subpage page_iface_zxdg_popup_v6 - short-lived, popup surfaces for menus
/// @section page_copyright_xdg_shell_unstable_v6 Copyright
/// <pre>
///
/// Copyright © 2008-2013 Kristian Høgsberg
/// Copyright © 2013      Rafael Antognolli
/// Copyright © 2013      Jasper St. Pierre
/// Copyright © 2010-2013 Intel Corporation
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// </pre>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct dwl_context {
    pub _bindgen_opaque_blob: [u64; 52usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwl_dmabuf {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwl_surface {
    pub _bindgen_opaque_blob: [u64; 12usize],
}

#[allow(dead_code)]
pub const DWL_KEYBOARD_KEY_STATE_RELEASED: i32 = 0;
pub const DWL_KEYBOARD_KEY_STATE_PRESSED: i32 = 1;

#[allow(dead_code)]
pub const DWL_EVENT_TYPE_KEYBOARD_ENTER: u32 = 0x00;
#[allow(dead_code)]
pub const DWL_EVENT_TYPE_KEYBOARD_LEAVE: u32 = 0x01;
pub const DWL_EVENT_TYPE_KEYBOARD_KEY: u32 = 0x02;
#[allow(dead_code)]
pub const DWL_EVENT_TYPE_POINTER_ENTER: u32 = 0x10;
#[allow(dead_code)]
pub const DWL_EVENT_TYPE_POINTER_LEAVE: u32 = 0x11;
#[allow(dead_code)]
pub const DWL_EVENT_TYPE_POINTER_MOVE: u32 = 0x12;
#[allow(dead_code)]
pub const DWL_EVENT_TYPE_POINTER_BUTTON: u32 = 0x13;
pub const DWL_EVENT_TYPE_TOUCH_DOWN: u32 = 0x20;
pub const DWL_EVENT_TYPE_TOUCH_UP: u32 = 0x21;
pub const DWL_EVENT_TYPE_TOUCH_MOTION: u32 = 0x22;

pub const DWL_SURFACE_FLAG_RECEIVE_INPUT: u32 = 1 << 0;
pub const DWL_SURFACE_FLAG_HAS_ALPHA: u32 = 1 << 1;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwl_event {
    pub surface_descriptor: *const ::std::ffi::c_void,
    pub event_type: u32,
    pub params: [i32; 3usize],
}

#[allow(non_camel_case_types)]
pub type dwl_error_callback_type =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;

extern "C" {
    pub fn dwl_context_new(log_proc: dwl_error_callback_type) -> *mut dwl_context;
}
extern "C" {
    pub fn dwl_context_destroy(self_: *mut *mut dwl_context);
}
extern "C" {
    pub fn dwl_context_setup(
        self_: *mut dwl_context,
        socket_path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn dwl_context_fd(self_: *mut dwl_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dwl_context_dispatch(self_: *mut dwl_context);
}
extern "C" {
    pub fn dwl_context_dmabuf_new(
        self_: *mut dwl_context,
        import_id: u32,
        fd: ::std::os::raw::c_int,
        offset: u32,
        stride: u32,
        modifiers: u64,
        width: u32,
        height: u32,
        fourcc: u32,
    ) -> *mut dwl_dmabuf;
}
extern "C" {
    pub fn dwl_dmabuf_destroy(self_: *mut *mut dwl_dmabuf);
}
extern "C" {
    pub fn dwl_context_surface_new(
        self_: *mut dwl_context,
        parent_id: u32,
        surface_id: u32,
        shm_fd: ::std::os::raw::c_int,
        shm_size: usize,
        buffer_size: usize,
        width: u32,
        height: u32,
        stride: u32,
        flags: u32,
    ) -> *mut dwl_surface;
}

extern "C" {
    pub fn dwl_surface_destroy(self_: *mut *mut dwl_surface);
}
extern "C" {
    pub fn dwl_surface_commit(self_: *mut dwl_surface);
}
extern "C" {
    pub fn dwl_surface_buffer_in_use(self_: *mut dwl_surface, buffer_index: usize) -> bool;
}
extern "C" {
    pub fn dwl_surface_flip(self_: *mut dwl_surface, buffer_index: usize);
}
extern "C" {
    pub fn dwl_surface_flip_to(self_: *mut dwl_surface, import_id: u32);
}
extern "C" {
    pub fn dwl_surface_close_requested(self_: *const dwl_surface) -> bool;
}
extern "C" {
    pub fn dwl_surface_set_position(self_: *mut dwl_surface, x: u32, y: u32);
}
extern "C" {
    pub fn dwl_surface_descriptor(self_: *const dwl_surface) -> *const ::std::ffi::c_void;
}
extern "C" {
    pub fn dwl_context_pending_events(self_: *const dwl_context) -> bool;
}
extern "C" {
    pub fn dwl_context_next_event(self_: *mut dwl_context, event: *mut dwl_event);
}
extern "C" {
    pub fn dwl_surface_set_scanout_id(self_: *mut dwl_surface, scanout_id: u32);
}
