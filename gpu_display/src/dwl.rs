// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/* automatically generated by rust-bindgen */

/// @page page_xdg_shell_unstable_v6 The xdg_shell_unstable_v6 protocol
/// @section page_ifaces_xdg_shell_unstable_v6 Interfaces
/// - @subpage page_iface_zxdg_shell_v6 - create desktop-style surfaces
/// - @subpage page_iface_zxdg_positioner_v6 - child surface positioner
/// - @subpage page_iface_zxdg_surface_v6 - desktop user interface surface base interface
/// - @subpage page_iface_zxdg_toplevel_v6 - toplevel surface
/// - @subpage page_iface_zxdg_popup_v6 - short-lived, popup surfaces for menus
/// @section page_copyright_xdg_shell_unstable_v6 Copyright
/// <pre>
///
/// Copyright © 2008-2013 Kristian Høgsberg
/// Copyright © 2013      Rafael Antognolli
/// Copyright © 2013      Jasper St. Pierre
/// Copyright © 2010-2013 Intel Corporation
///
/// Permission is hereby granted, free of charge, to any person obtaining a
/// copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation
/// the rights to use, copy, modify, merge, publish, distribute, sublicense,
/// and/or sell copies of the Software, and to permit persons to whom the
/// Software is furnished to do so, subject to the following conditions:
///
/// The above copyright notice and this permission notice (including the next
/// paragraph) shall be included in all copies or substantial portions of the
/// Software.
///
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
/// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
/// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
/// DEALINGS IN THE SOFTWARE.
/// </pre>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wl_output {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct dwl_context {
    pub _bindgen_opaque_blob: [u64; 52usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwl_dmabuf {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dwl_surface {
    pub _bindgen_opaque_blob: [u64; 12usize],
}
extern "C" {
    pub fn dwl_context_new() -> *mut dwl_context;
}
extern "C" {
    pub fn dwl_context_destroy(self_: *mut *mut dwl_context);
}
extern "C" {
    pub fn dwl_context_setup(
        self_: *mut dwl_context,
        socket_path: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn dwl_context_fd(self_: *mut dwl_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dwl_context_dispatch(self_: *mut dwl_context);
}
extern "C" {
    pub fn dwl_context_dmabuf_new(
        self_: *mut dwl_context,
        fd: ::std::os::raw::c_int,
        offset: u32,
        stride: u32,
        modifiers: u64,
        width: u32,
        height: u32,
        fourcc: u32,
    ) -> *mut dwl_dmabuf;
}
extern "C" {
    pub fn dwl_dmabuf_destroy(self_: *mut *mut dwl_dmabuf);
}
extern "C" {
    pub fn dwl_context_surface_new(
        self_: *mut dwl_context,
        parent: *mut dwl_surface,
        shm_fd: ::std::os::raw::c_int,
        shm_size: usize,
        buffer_size: usize,
        width: u32,
        height: u32,
        stride: u32,
    ) -> *mut dwl_surface;
}
extern "C" {
    pub fn dwl_surface_destroy(self_: *mut *mut dwl_surface);
}
extern "C" {
    pub fn dwl_surface_commit(self_: *mut dwl_surface);
}
extern "C" {
    pub fn dwl_surface_buffer_in_use(self_: *mut dwl_surface, buffer_index: usize) -> bool;
}
extern "C" {
    pub fn dwl_surface_flip(self_: *mut dwl_surface, buffer_index: usize);
}
extern "C" {
    pub fn dwl_surface_flip_to(self_: *mut dwl_surface, dmabuf: *mut dwl_dmabuf);
}
extern "C" {
    pub fn dwl_surface_close_requested(self_: *const dwl_surface) -> bool;
}
extern "C" {
    pub fn dwl_surface_set_position(self_: *mut dwl_surface, x: u32, y: u32);
}
