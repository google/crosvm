/* automatically generated by tools/bindgen-all-the-things */

#![allow(clippy::missing_safety_doc)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::upper_case_acronyms)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use libc::sockaddr;

#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: ::std::os::raw::c_uint,
    pub clock_type: ::std::os::raw::c_uint,
    pub loopback: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: ::std::os::raw::c_uint,
    pub clock_type: ::std::os::raw::c_uint,
    pub loopback: ::std::os::raw::c_ushort,
    pub slot_map: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: ::std::os::raw::c_ushort,
    pub parity: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto {
    pub t391: ::std::os::raw::c_uint,
    pub t392: ::std::os::raw::c_uint,
    pub n391: ::std::os::raw::c_uint,
    pub n392: ::std::os::raw::c_uint,
    pub n393: ::std::os::raw::c_uint,
    pub lmi: ::std::os::raw::c_ushort,
    pub dce: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: ::std::os::raw::c_uint,
    pub master: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cisco_proto {
    pub interval: ::std::os::raw::c_uint,
    pub timeout: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: ::std::os::raw::c_ushort,
    pub modulo: ::std::os::raw::c_uint,
    pub window: ::std::os::raw::c_uint,
    pub t1: ::std::os::raw::c_uint,
    pub t2: ::std::os::raw::c_uint,
    pub n2: ::std::os::raw::c_uint,
}
impl net_device_flags {
    pub const IFF_UP: net_device_flags = net_device_flags(1);
}
impl net_device_flags {
    pub const IFF_BROADCAST: net_device_flags = net_device_flags(2);
}
impl net_device_flags {
    pub const IFF_DEBUG: net_device_flags = net_device_flags(4);
}
impl net_device_flags {
    pub const IFF_LOOPBACK: net_device_flags = net_device_flags(8);
}
impl net_device_flags {
    pub const IFF_POINTOPOINT: net_device_flags = net_device_flags(16);
}
impl net_device_flags {
    pub const IFF_NOTRAILERS: net_device_flags = net_device_flags(32);
}
impl net_device_flags {
    pub const IFF_RUNNING: net_device_flags = net_device_flags(64);
}
impl net_device_flags {
    pub const IFF_NOARP: net_device_flags = net_device_flags(128);
}
impl net_device_flags {
    pub const IFF_PROMISC: net_device_flags = net_device_flags(256);
}
impl net_device_flags {
    pub const IFF_ALLMULTI: net_device_flags = net_device_flags(512);
}
impl net_device_flags {
    pub const IFF_MASTER: net_device_flags = net_device_flags(1024);
}
impl net_device_flags {
    pub const IFF_SLAVE: net_device_flags = net_device_flags(2048);
}
impl net_device_flags {
    pub const IFF_MULTICAST: net_device_flags = net_device_flags(4096);
}
impl net_device_flags {
    pub const IFF_PORTSEL: net_device_flags = net_device_flags(8192);
}
impl net_device_flags {
    pub const IFF_AUTOMEDIA: net_device_flags = net_device_flags(16384);
}
impl net_device_flags {
    pub const IFF_DYNAMIC: net_device_flags = net_device_flags(32768);
}
impl net_device_flags {
    pub const IFF_LOWER_UP: net_device_flags = net_device_flags(65536);
}
impl net_device_flags {
    pub const IFF_DORMANT: net_device_flags = net_device_flags(131072);
}
impl net_device_flags {
    pub const IFF_ECHO: net_device_flags = net_device_flags(262144);
}
impl ::std::ops::BitOr<net_device_flags> for net_device_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        net_device_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for net_device_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: net_device_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<net_device_flags> for net_device_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        net_device_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for net_device_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: net_device_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct net_device_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ifmap {
    pub mem_start: ::std::os::raw::c_ulong,
    pub mem_end: ::std::os::raw::c_ulong,
    pub base_addr: ::std::os::raw::c_ushort,
    pub irq: ::std::os::raw::c_uchar,
    pub dma: ::std::os::raw::c_uchar,
    pub port: ::std::os::raw::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
}
impl Default for if_settings__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for if_settings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [::std::os::raw::c_char; 16usize],
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: ::std::os::raw::c_short,
    pub ifru_ivalue: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_map: ifmap,
    pub ifru_slave: [::std::os::raw::c_char; 16usize],
    pub ifru_newname: [::std::os::raw::c_char; 16usize],
    pub ifru_data: *mut ::std::os::raw::c_void,
    pub ifru_settings: if_settings,
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ifreq {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
